///
/// ReactNativeHealthkit-Swift-Cxx-Bridge.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

// Forward declarations of C++ defined types
// Forward declaration of `AnyMap` to properly resolve imports.
namespace NitroModules { class AnyMap; }
// Forward declaration of `AuthorizationRequestStatus` to properly resolve imports.
namespace margelo::nitro::healthkit { enum class AuthorizationRequestStatus; }
// Forward declaration of `AuthorizationStatus` to properly resolve imports.
namespace margelo::nitro::healthkit { enum class AuthorizationStatus; }
// Forward declaration of `BiologicalSex` to properly resolve imports.
namespace margelo::nitro::healthkit { enum class BiologicalSex; }
// Forward declaration of `BloodType` to properly resolve imports.
namespace margelo::nitro::healthkit { enum class BloodType; }
// Forward declaration of `CategorySampleForSaving` to properly resolve imports.
namespace margelo::nitro::healthkit { struct CategorySampleForSaving; }
// Forward declaration of `CategorySample` to properly resolve imports.
namespace margelo::nitro::healthkit { struct CategorySample; }
// Forward declaration of `CategorySamplesWithAnchorResponse` to properly resolve imports.
namespace margelo::nitro::healthkit { struct CategorySamplesWithAnchorResponse; }
// Forward declaration of `CategoryTypeIdentifier` to properly resolve imports.
namespace margelo::nitro::healthkit { enum class CategoryTypeIdentifier; }
// Forward declaration of `ComparisonPredicateOperator` to properly resolve imports.
namespace margelo::nitro::healthkit { enum class ComparisonPredicateOperator; }
// Forward declaration of `CorrelationSample` to properly resolve imports.
namespace margelo::nitro::healthkit { struct CorrelationSample; }
// Forward declaration of `CorrelationTypeIdentifier` to properly resolve imports.
namespace margelo::nitro::healthkit { enum class CorrelationTypeIdentifier; }
// Forward declaration of `DeletedSample` to properly resolve imports.
namespace margelo::nitro::healthkit { struct DeletedSample; }
// Forward declaration of `Device` to properly resolve imports.
namespace margelo::nitro::healthkit { struct Device; }
// Forward declaration of `ECGQueryOptionsWithSortOrder` to properly resolve imports.
namespace margelo::nitro::healthkit { struct ECGQueryOptionsWithSortOrder; }
// Forward declaration of `ElectrocardiogramClassification` to properly resolve imports.
namespace margelo::nitro::healthkit { enum class ElectrocardiogramClassification; }
// Forward declaration of `ElectrocardiogramLead` to properly resolve imports.
namespace margelo::nitro::healthkit { enum class ElectrocardiogramLead; }
// Forward declaration of `ElectrocardiogramSample` to properly resolve imports.
namespace margelo::nitro::healthkit { struct ElectrocardiogramSample; }
// Forward declaration of `ElectrocardiogramSamplesWithAnchorResponse` to properly resolve imports.
namespace margelo::nitro::healthkit { struct ElectrocardiogramSamplesWithAnchorResponse; }
// Forward declaration of `ElectrocardiogramSymptomsStatus` to properly resolve imports.
namespace margelo::nitro::healthkit { enum class ElectrocardiogramSymptomsStatus; }
// Forward declaration of `ElectrocardiogramVoltage` to properly resolve imports.
namespace margelo::nitro::healthkit { struct ElectrocardiogramVoltage; }
// Forward declaration of `FilterForSamplesAnd` to properly resolve imports.
namespace margelo::nitro::healthkit { struct FilterForSamplesAnd; }
// Forward declaration of `FilterForSamplesOr` to properly resolve imports.
namespace margelo::nitro::healthkit { struct FilterForSamplesOr; }
// Forward declaration of `FitzpatrickSkinType` to properly resolve imports.
namespace margelo::nitro::healthkit { enum class FitzpatrickSkinType; }
// Forward declaration of `HeartbeatSeriesSample` to properly resolve imports.
namespace margelo::nitro::healthkit { struct HeartbeatSeriesSample; }
// Forward declaration of `HeartbeatSeriesSamplesWithAnchorResponse` to properly resolve imports.
namespace margelo::nitro::healthkit { struct HeartbeatSeriesSamplesWithAnchorResponse; }
// Forward declaration of `Heartbeat` to properly resolve imports.
namespace margelo::nitro::healthkit { struct Heartbeat; }
// Forward declaration of `HybridCategoryTypeModuleSpec` to properly resolve imports.
namespace margelo::nitro::healthkit { class HybridCategoryTypeModuleSpec; }
// Forward declaration of `HybridCharacteristicTypeModuleSpec` to properly resolve imports.
namespace margelo::nitro::healthkit { class HybridCharacteristicTypeModuleSpec; }
// Forward declaration of `HybridCoreModuleSpec` to properly resolve imports.
namespace margelo::nitro::healthkit { class HybridCoreModuleSpec; }
// Forward declaration of `HybridCorrelationTypeModuleSpec` to properly resolve imports.
namespace margelo::nitro::healthkit { class HybridCorrelationTypeModuleSpec; }
// Forward declaration of `HybridElectrocardiogramModuleSpec` to properly resolve imports.
namespace margelo::nitro::healthkit { class HybridElectrocardiogramModuleSpec; }
// Forward declaration of `HybridHeartbeatSeriesModuleSpec` to properly resolve imports.
namespace margelo::nitro::healthkit { class HybridHeartbeatSeriesModuleSpec; }
// Forward declaration of `HybridQuantityTypeModuleSpec` to properly resolve imports.
namespace margelo::nitro::healthkit { class HybridQuantityTypeModuleSpec; }
// Forward declaration of `HybridSourceProxySpec` to properly resolve imports.
namespace margelo::nitro::healthkit { class HybridSourceProxySpec; }
// Forward declaration of `HybridStateOfMindModuleSpec` to properly resolve imports.
namespace margelo::nitro::healthkit { class HybridStateOfMindModuleSpec; }
// Forward declaration of `HybridWorkoutProxySpec` to properly resolve imports.
namespace margelo::nitro::healthkit { class HybridWorkoutProxySpec; }
// Forward declaration of `HybridWorkoutsModuleSpec` to properly resolve imports.
namespace margelo::nitro::healthkit { class HybridWorkoutsModuleSpec; }
// Forward declaration of `IdentifierWithUnit` to properly resolve imports.
namespace margelo::nitro::healthkit { struct IdentifierWithUnit; }
// Forward declaration of `LocationForSaving` to properly resolve imports.
namespace margelo::nitro::healthkit { struct LocationForSaving; }
// Forward declaration of `ObjectTypeIdentifier` to properly resolve imports.
namespace margelo::nitro::healthkit { enum class ObjectTypeIdentifier; }
// Forward declaration of `OnChangeCallbackArgs` to properly resolve imports.
namespace margelo::nitro::healthkit { struct OnChangeCallbackArgs; }
// Forward declaration of `PredicateForWorkoutsAnd` to properly resolve imports.
namespace margelo::nitro::healthkit { struct PredicateForWorkoutsAnd; }
// Forward declaration of `PredicateForWorkoutsOr` to properly resolve imports.
namespace margelo::nitro::healthkit { struct PredicateForWorkoutsOr; }
// Forward declaration of `PredicateFromWorkout` to properly resolve imports.
namespace margelo::nitro::healthkit { struct PredicateFromWorkout; }
// Forward declaration of `PredicateWithMetadataKey` to properly resolve imports.
namespace margelo::nitro::healthkit { struct PredicateWithMetadataKey; }
// Forward declaration of `PredicateWithMetadataOperator` to properly resolve imports.
namespace margelo::nitro::healthkit { enum class PredicateWithMetadataOperator; }
// Forward declaration of `PredicateWithStartAndEnd` to properly resolve imports.
namespace margelo::nitro::healthkit { struct PredicateWithStartAndEnd; }
// Forward declaration of `PredicateWithUUID` to properly resolve imports.
namespace margelo::nitro::healthkit { struct PredicateWithUUID; }
// Forward declaration of `PredicateWithUUIDs` to properly resolve imports.
namespace margelo::nitro::healthkit { struct PredicateWithUUIDs; }
// Forward declaration of `QuantityDateInterval` to properly resolve imports.
namespace margelo::nitro::healthkit { struct QuantityDateInterval; }
// Forward declaration of `QuantitySampleForSaving` to properly resolve imports.
namespace margelo::nitro::healthkit { struct QuantitySampleForSaving; }
// Forward declaration of `QuantitySample` to properly resolve imports.
namespace margelo::nitro::healthkit { struct QuantitySample; }
// Forward declaration of `QuantitySamplesWithAnchorResponse` to properly resolve imports.
namespace margelo::nitro::healthkit { struct QuantitySamplesWithAnchorResponse; }
// Forward declaration of `QuantityTypeIdentifier` to properly resolve imports.
namespace margelo::nitro::healthkit { enum class QuantityTypeIdentifier; }
// Forward declaration of `Quantity` to properly resolve imports.
namespace margelo::nitro::healthkit { struct Quantity; }
// Forward declaration of `QueryOptionsWithSortOrderAndUnit` to properly resolve imports.
namespace margelo::nitro::healthkit { struct QueryOptionsWithSortOrderAndUnit; }
// Forward declaration of `QueryOptionsWithSortOrder` to properly resolve imports.
namespace margelo::nitro::healthkit { struct QueryOptionsWithSortOrder; }
// Forward declaration of `QueryStatisticsResponse` to properly resolve imports.
namespace margelo::nitro::healthkit { struct QueryStatisticsResponse; }
// Forward declaration of `QueryWorkoutSamplesWithAnchorResponse` to properly resolve imports.
namespace margelo::nitro::healthkit { struct QueryWorkoutSamplesWithAnchorResponse; }
// Forward declaration of `SampleTypeIdentifierWriteable` to properly resolve imports.
namespace margelo::nitro::healthkit { enum class SampleTypeIdentifierWriteable; }
// Forward declaration of `SampleTypeIdentifier` to properly resolve imports.
namespace margelo::nitro::healthkit { enum class SampleTypeIdentifier; }
// Forward declaration of `SourceRevision` to properly resolve imports.
namespace margelo::nitro::healthkit { struct SourceRevision; }
// Forward declaration of `Source` to properly resolve imports.
namespace margelo::nitro::healthkit { struct Source; }
// Forward declaration of `StateOfMindAssociation` to properly resolve imports.
namespace margelo::nitro::healthkit { enum class StateOfMindAssociation; }
// Forward declaration of `StateOfMindKind` to properly resolve imports.
namespace margelo::nitro::healthkit { enum class StateOfMindKind; }
// Forward declaration of `StateOfMindLabel` to properly resolve imports.
namespace margelo::nitro::healthkit { enum class StateOfMindLabel; }
// Forward declaration of `StateOfMindSample` to properly resolve imports.
namespace margelo::nitro::healthkit { struct StateOfMindSample; }
// Forward declaration of `StateOfMindValenceClassification` to properly resolve imports.
namespace margelo::nitro::healthkit { enum class StateOfMindValenceClassification; }
// Forward declaration of `StatisticsOptions` to properly resolve imports.
namespace margelo::nitro::healthkit { enum class StatisticsOptions; }
// Forward declaration of `StatisticsQueryOptions` to properly resolve imports.
namespace margelo::nitro::healthkit { struct StatisticsQueryOptions; }
// Forward declaration of `WheelchairUse` to properly resolve imports.
namespace margelo::nitro::healthkit { enum class WheelchairUse; }
// Forward declaration of `WorkoutActivityTypePredicate` to properly resolve imports.
namespace margelo::nitro::healthkit { struct WorkoutActivityTypePredicate; }
// Forward declaration of `WorkoutActivityType` to properly resolve imports.
namespace margelo::nitro::healthkit { enum class WorkoutActivityType; }
// Forward declaration of `WorkoutActivity` to properly resolve imports.
namespace margelo::nitro::healthkit { struct WorkoutActivity; }
// Forward declaration of `WorkoutDurationPredicate` to properly resolve imports.
namespace margelo::nitro::healthkit { struct WorkoutDurationPredicate; }
// Forward declaration of `WorkoutEventType` to properly resolve imports.
namespace margelo::nitro::healthkit { enum class WorkoutEventType; }
// Forward declaration of `WorkoutEvent` to properly resolve imports.
namespace margelo::nitro::healthkit { struct WorkoutEvent; }
// Forward declaration of `WorkoutPlan` to properly resolve imports.
namespace margelo::nitro::healthkit { struct WorkoutPlan; }
// Forward declaration of `WorkoutRouteLocation` to properly resolve imports.
namespace margelo::nitro::healthkit { struct WorkoutRouteLocation; }
// Forward declaration of `WorkoutRoute` to properly resolve imports.
namespace margelo::nitro::healthkit { struct WorkoutRoute; }
// Forward declaration of `WorkoutSample` to properly resolve imports.
namespace margelo::nitro::healthkit { struct WorkoutSample; }
// Forward declaration of `WorkoutSessionLocationType` to properly resolve imports.
namespace margelo::nitro::healthkit { enum class WorkoutSessionLocationType; }

// Forward declarations of Swift defined types
// Forward declaration of `HybridCategoryTypeModuleSpec_cxx` to properly resolve imports.
namespace ReactNativeHealthkit { class HybridCategoryTypeModuleSpec_cxx; }
// Forward declaration of `HybridCharacteristicTypeModuleSpec_cxx` to properly resolve imports.
namespace ReactNativeHealthkit { class HybridCharacteristicTypeModuleSpec_cxx; }
// Forward declaration of `HybridCoreModuleSpec_cxx` to properly resolve imports.
namespace ReactNativeHealthkit { class HybridCoreModuleSpec_cxx; }
// Forward declaration of `HybridCorrelationTypeModuleSpec_cxx` to properly resolve imports.
namespace ReactNativeHealthkit { class HybridCorrelationTypeModuleSpec_cxx; }
// Forward declaration of `HybridElectrocardiogramModuleSpec_cxx` to properly resolve imports.
namespace ReactNativeHealthkit { class HybridElectrocardiogramModuleSpec_cxx; }
// Forward declaration of `HybridHeartbeatSeriesModuleSpec_cxx` to properly resolve imports.
namespace ReactNativeHealthkit { class HybridHeartbeatSeriesModuleSpec_cxx; }
// Forward declaration of `HybridQuantityTypeModuleSpec_cxx` to properly resolve imports.
namespace ReactNativeHealthkit { class HybridQuantityTypeModuleSpec_cxx; }
// Forward declaration of `HybridSourceProxySpec_cxx` to properly resolve imports.
namespace ReactNativeHealthkit { class HybridSourceProxySpec_cxx; }
// Forward declaration of `HybridStateOfMindModuleSpec_cxx` to properly resolve imports.
namespace ReactNativeHealthkit { class HybridStateOfMindModuleSpec_cxx; }
// Forward declaration of `HybridWorkoutProxySpec_cxx` to properly resolve imports.
namespace ReactNativeHealthkit { class HybridWorkoutProxySpec_cxx; }
// Forward declaration of `HybridWorkoutsModuleSpec_cxx` to properly resolve imports.
namespace ReactNativeHealthkit { class HybridWorkoutsModuleSpec_cxx; }

// Include C++ defined types
#include "AuthorizationRequestStatus.hpp"
#include "AuthorizationStatus.hpp"
#include "BiologicalSex.hpp"
#include "BloodType.hpp"
#include "CategorySample.hpp"
#include "CategorySampleForSaving.hpp"
#include "CategorySamplesWithAnchorResponse.hpp"
#include "CategoryTypeIdentifier.hpp"
#include "ComparisonPredicateOperator.hpp"
#include "CorrelationSample.hpp"
#include "CorrelationTypeIdentifier.hpp"
#include "DeletedSample.hpp"
#include "Device.hpp"
#include "ECGQueryOptionsWithSortOrder.hpp"
#include "ElectrocardiogramClassification.hpp"
#include "ElectrocardiogramLead.hpp"
#include "ElectrocardiogramSample.hpp"
#include "ElectrocardiogramSamplesWithAnchorResponse.hpp"
#include "ElectrocardiogramSymptomsStatus.hpp"
#include "ElectrocardiogramVoltage.hpp"
#include "FilterForSamplesAnd.hpp"
#include "FilterForSamplesOr.hpp"
#include "FitzpatrickSkinType.hpp"
#include "Heartbeat.hpp"
#include "HeartbeatSeriesSample.hpp"
#include "HeartbeatSeriesSamplesWithAnchorResponse.hpp"
#include "HybridCategoryTypeModuleSpec.hpp"
#include "HybridCharacteristicTypeModuleSpec.hpp"
#include "HybridCoreModuleSpec.hpp"
#include "HybridCorrelationTypeModuleSpec.hpp"
#include "HybridElectrocardiogramModuleSpec.hpp"
#include "HybridHeartbeatSeriesModuleSpec.hpp"
#include "HybridQuantityTypeModuleSpec.hpp"
#include "HybridSourceProxySpec.hpp"
#include "HybridStateOfMindModuleSpec.hpp"
#include "HybridWorkoutProxySpec.hpp"
#include "HybridWorkoutsModuleSpec.hpp"
#include "IdentifierWithUnit.hpp"
#include "LocationForSaving.hpp"
#include "ObjectTypeIdentifier.hpp"
#include "OnChangeCallbackArgs.hpp"
#include "PredicateForWorkoutsAnd.hpp"
#include "PredicateForWorkoutsOr.hpp"
#include "PredicateFromWorkout.hpp"
#include "PredicateWithMetadataKey.hpp"
#include "PredicateWithMetadataOperator.hpp"
#include "PredicateWithStartAndEnd.hpp"
#include "PredicateWithUUID.hpp"
#include "PredicateWithUUIDs.hpp"
#include "Quantity.hpp"
#include "QuantityDateInterval.hpp"
#include "QuantitySample.hpp"
#include "QuantitySampleForSaving.hpp"
#include "QuantitySamplesWithAnchorResponse.hpp"
#include "QuantityTypeIdentifier.hpp"
#include "QueryOptionsWithSortOrder.hpp"
#include "QueryOptionsWithSortOrderAndUnit.hpp"
#include "QueryStatisticsResponse.hpp"
#include "QueryWorkoutSamplesWithAnchorResponse.hpp"
#include "SampleTypeIdentifier.hpp"
#include "SampleTypeIdentifierWriteable.hpp"
#include "Source.hpp"
#include "SourceRevision.hpp"
#include "StateOfMindAssociation.hpp"
#include "StateOfMindKind.hpp"
#include "StateOfMindLabel.hpp"
#include "StateOfMindSample.hpp"
#include "StateOfMindValenceClassification.hpp"
#include "StatisticsOptions.hpp"
#include "StatisticsQueryOptions.hpp"
#include "WheelchairUse.hpp"
#include "WorkoutActivity.hpp"
#include "WorkoutActivityType.hpp"
#include "WorkoutActivityTypePredicate.hpp"
#include "WorkoutDurationPredicate.hpp"
#include "WorkoutEvent.hpp"
#include "WorkoutEventType.hpp"
#include "WorkoutPlan.hpp"
#include "WorkoutRoute.hpp"
#include "WorkoutRouteLocation.hpp"
#include "WorkoutSample.hpp"
#include "WorkoutSessionLocationType.hpp"
#include <NitroModules/AnyMap.hpp>
#include <NitroModules/FastVectorCopy.hpp>
#include <NitroModules/Promise.hpp>
#include <NitroModules/PromiseHolder.hpp>
#include <NitroModules/Result.hpp>
#include <chrono>
#include <exception>
#include <functional>
#include <memory>
#include <optional>
#include <string>
#include <unordered_map>
#include <variant>
#include <vector>

/**
 * Contains specialized versions of C++ templated types so they can be accessed from Swift,
 * as well as helper functions to interact with those C++ types from Swift.
 */
namespace margelo::nitro::healthkit::bridge::swift {

  // pragma MARK: std::shared_ptr<Promise<bool>>
  /**
   * Specialized version of `std::shared_ptr<Promise<bool>>`.
   */
  using std__shared_ptr_Promise_bool__ = std::shared_ptr<Promise<bool>>;
  inline std::shared_ptr<Promise<bool>> create_std__shared_ptr_Promise_bool__() noexcept {
    return Promise<bool>::create();
  }
  inline PromiseHolder<bool> wrap_std__shared_ptr_Promise_bool__(std::shared_ptr<Promise<bool>> promise) noexcept {
    return PromiseHolder<bool>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(bool /* result */)>
  /**
   * Specialized version of `std::function<void(bool)>`.
   */
  using Func_void_bool = std::function<void(bool /* result */)>;
  /**
   * Wrapper class for a `std::function<void(bool / * result * /)>`, this can be used from Swift.
   */
  class Func_void_bool_Wrapper final {
  public:
    explicit Func_void_bool_Wrapper(std::function<void(bool /* result */)>&& func): _function(std::make_unique<std::function<void(bool /* result */)>>(std::move(func))) {}
    inline void call(bool result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(bool /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_bool create_Func_void_bool(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_bool_Wrapper wrap_Func_void_bool(Func_void_bool value) noexcept {
    return Func_void_bool_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const std::exception_ptr& /* error */)>
  /**
   * Specialized version of `std::function<void(const std::exception_ptr&)>`.
   */
  using Func_void_std__exception_ptr = std::function<void(const std::exception_ptr& /* error */)>;
  /**
   * Wrapper class for a `std::function<void(const std::exception_ptr& / * error * /)>`, this can be used from Swift.
   */
  class Func_void_std__exception_ptr_Wrapper final {
  public:
    explicit Func_void_std__exception_ptr_Wrapper(std::function<void(const std::exception_ptr& /* error */)>&& func): _function(std::make_unique<std::function<void(const std::exception_ptr& /* error */)>>(std::move(func))) {}
    inline void call(std::exception_ptr error) const noexcept {
      _function->operator()(error);
    }
  private:
    std::unique_ptr<std::function<void(const std::exception_ptr& /* error */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__exception_ptr create_Func_void_std__exception_ptr(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__exception_ptr_Wrapper wrap_Func_void_std__exception_ptr(Func_void_std__exception_ptr value) noexcept {
    return Func_void_std__exception_ptr_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<std::string>
  /**
   * Specialized version of `std::optional<std::string>`.
   */
  using std__optional_std__string_ = std::optional<std::string>;
  inline std::optional<std::string> create_std__optional_std__string_(const std::string& value) noexcept {
    return std::optional<std::string>(value);
  }
  inline bool has_value_std__optional_std__string_(const std::optional<std::string>& optional) noexcept {
    return optional.has_value();
  }
  inline std::string get_std__optional_std__string_(const std::optional<std::string>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<Device>
  /**
   * Specialized version of `std::optional<Device>`.
   */
  using std__optional_Device_ = std::optional<Device>;
  inline std::optional<Device> create_std__optional_Device_(const Device& value) noexcept {
    return std::optional<Device>(value);
  }
  inline bool has_value_std__optional_Device_(const std::optional<Device>& optional) noexcept {
    return optional.has_value();
  }
  inline Device get_std__optional_Device_(const std::optional<Device>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::shared_ptr<HybridSourceProxySpec>
  /**
   * Specialized version of `std::shared_ptr<HybridSourceProxySpec>`.
   */
  using std__shared_ptr_HybridSourceProxySpec_ = std::shared_ptr<HybridSourceProxySpec>;
  std::shared_ptr<HybridSourceProxySpec> create_std__shared_ptr_HybridSourceProxySpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridSourceProxySpec_(std__shared_ptr_HybridSourceProxySpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridSourceProxySpec>
  using std__weak_ptr_HybridSourceProxySpec_ = std::weak_ptr<HybridSourceProxySpec>;
  inline std__weak_ptr_HybridSourceProxySpec_ weakify_std__shared_ptr_HybridSourceProxySpec_(const std::shared_ptr<HybridSourceProxySpec>& strong) noexcept { return strong; }
  
  // pragma MARK: std::optional<std::shared_ptr<HybridSourceProxySpec>>
  /**
   * Specialized version of `std::optional<std::shared_ptr<HybridSourceProxySpec>>`.
   */
  using std__optional_std__shared_ptr_HybridSourceProxySpec__ = std::optional<std::shared_ptr<HybridSourceProxySpec>>;
  inline std::optional<std::shared_ptr<HybridSourceProxySpec>> create_std__optional_std__shared_ptr_HybridSourceProxySpec__(const std::shared_ptr<HybridSourceProxySpec>& value) noexcept {
    return std::optional<std::shared_ptr<HybridSourceProxySpec>>(value);
  }
  inline bool has_value_std__optional_std__shared_ptr_HybridSourceProxySpec__(const std::optional<std::shared_ptr<HybridSourceProxySpec>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::shared_ptr<HybridSourceProxySpec> get_std__optional_std__shared_ptr_HybridSourceProxySpec__(const std::optional<std::shared_ptr<HybridSourceProxySpec>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<SourceRevision>
  /**
   * Specialized version of `std::optional<SourceRevision>`.
   */
  using std__optional_SourceRevision_ = std::optional<SourceRevision>;
  inline std::optional<SourceRevision> create_std__optional_SourceRevision_(const SourceRevision& value) noexcept {
    return std::optional<SourceRevision>(value);
  }
  inline bool has_value_std__optional_SourceRevision_(const std::optional<SourceRevision>& optional) noexcept {
    return optional.has_value();
  }
  inline SourceRevision get_std__optional_SourceRevision_(const std::optional<SourceRevision>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<CategorySample>
  /**
   * Specialized version of `std::vector<CategorySample>`.
   */
  using std__vector_CategorySample_ = std::vector<CategorySample>;
  inline std::vector<CategorySample> create_std__vector_CategorySample_(size_t size) noexcept {
    std::vector<CategorySample> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::vector<CategorySample>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::vector<CategorySample>>>`.
   */
  using std__shared_ptr_Promise_std__vector_CategorySample___ = std::shared_ptr<Promise<std::vector<CategorySample>>>;
  inline std::shared_ptr<Promise<std::vector<CategorySample>>> create_std__shared_ptr_Promise_std__vector_CategorySample___() noexcept {
    return Promise<std::vector<CategorySample>>::create();
  }
  inline PromiseHolder<std::vector<CategorySample>> wrap_std__shared_ptr_Promise_std__vector_CategorySample___(std::shared_ptr<Promise<std::vector<CategorySample>>> promise) noexcept {
    return PromiseHolder<std::vector<CategorySample>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::vector<CategorySample>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::vector<CategorySample>&)>`.
   */
  using Func_void_std__vector_CategorySample_ = std::function<void(const std::vector<CategorySample>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::vector<CategorySample>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__vector_CategorySample__Wrapper final {
  public:
    explicit Func_void_std__vector_CategorySample__Wrapper(std::function<void(const std::vector<CategorySample>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::vector<CategorySample>& /* result */)>>(std::move(func))) {}
    inline void call(std::vector<CategorySample> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::vector<CategorySample>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__vector_CategorySample_ create_Func_void_std__vector_CategorySample_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__vector_CategorySample__Wrapper wrap_Func_void_std__vector_CategorySample_(Func_void_std__vector_CategorySample_ value) noexcept {
    return Func_void_std__vector_CategorySample__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<bool>
  /**
   * Specialized version of `std::optional<bool>`.
   */
  using std__optional_bool_ = std::optional<bool>;
  inline std::optional<bool> create_std__optional_bool_(const bool& value) noexcept {
    return std::optional<bool>(value);
  }
  inline bool has_value_std__optional_bool_(const std::optional<bool>& optional) noexcept {
    return optional.has_value();
  }
  inline bool get_std__optional_bool_(const std::optional<bool>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<std::string>
  /**
   * Specialized version of `std::vector<std::string>`.
   */
  using std__vector_std__string_ = std::vector<std::string>;
  inline std::vector<std::string> create_std__vector_std__string_(size_t size) noexcept {
    std::vector<std::string> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<PredicateWithMetadataOperator>
  /**
   * Specialized version of `std::optional<PredicateWithMetadataOperator>`.
   */
  using std__optional_PredicateWithMetadataOperator_ = std::optional<PredicateWithMetadataOperator>;
  inline std::optional<PredicateWithMetadataOperator> create_std__optional_PredicateWithMetadataOperator_(const PredicateWithMetadataOperator& value) noexcept {
    return std::optional<PredicateWithMetadataOperator>(value);
  }
  inline bool has_value_std__optional_PredicateWithMetadataOperator_(const std::optional<PredicateWithMetadataOperator>& optional) noexcept {
    return optional.has_value();
  }
  inline PredicateWithMetadataOperator get_std__optional_PredicateWithMetadataOperator_(const std::optional<PredicateWithMetadataOperator>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::variant<std::string, double, bool, std::chrono::system_clock::time_point>
  /**
   * Wrapper struct for `std::variant<std::string, double, bool, std::chrono::system_clock::time_point>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_std__string__double__bool__std__chrono__system_clock__time_point_ {
    std::variant<std::string, double, bool, std::chrono::system_clock::time_point> variant;
    std__variant_std__string__double__bool__std__chrono__system_clock__time_point_(std::variant<std::string, double, bool, std::chrono::system_clock::time_point> variant): variant(variant) { }
    operator std::variant<std::string, double, bool, std::chrono::system_clock::time_point>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline std::string get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline double get_1() const noexcept {
      return std::get<1>(variant);
    }
    inline bool get_2() const noexcept {
      return std::get<2>(variant);
    }
    inline std::chrono::system_clock::time_point get_3() const noexcept {
      return std::get<3>(variant);
    }
  };
  inline std__variant_std__string__double__bool__std__chrono__system_clock__time_point_ create_std__variant_std__string__double__bool__std__chrono__system_clock__time_point_(const std::string& value) noexcept {
    return std__variant_std__string__double__bool__std__chrono__system_clock__time_point_(value);
  }
  inline std__variant_std__string__double__bool__std__chrono__system_clock__time_point_ create_std__variant_std__string__double__bool__std__chrono__system_clock__time_point_(double value) noexcept {
    return std__variant_std__string__double__bool__std__chrono__system_clock__time_point_(value);
  }
  inline std__variant_std__string__double__bool__std__chrono__system_clock__time_point_ create_std__variant_std__string__double__bool__std__chrono__system_clock__time_point_(bool value) noexcept {
    return std__variant_std__string__double__bool__std__chrono__system_clock__time_point_(value);
  }
  inline std__variant_std__string__double__bool__std__chrono__system_clock__time_point_ create_std__variant_std__string__double__bool__std__chrono__system_clock__time_point_(std::chrono::system_clock::time_point value) noexcept {
    return std__variant_std__string__double__bool__std__chrono__system_clock__time_point_(value);
  }
  
  // pragma MARK: std::optional<std::variant<std::string, double, bool, std::chrono::system_clock::time_point>>
  /**
   * Specialized version of `std::optional<std::variant<std::string, double, bool, std::chrono::system_clock::time_point>>`.
   */
  using std__optional_std__variant_std__string__double__bool__std__chrono__system_clock__time_point__ = std::optional<std::variant<std::string, double, bool, std::chrono::system_clock::time_point>>;
  inline std::optional<std::variant<std::string, double, bool, std::chrono::system_clock::time_point>> create_std__optional_std__variant_std__string__double__bool__std__chrono__system_clock__time_point__(const std::variant<std::string, double, bool, std::chrono::system_clock::time_point>& value) noexcept {
    return std::optional<std::variant<std::string, double, bool, std::chrono::system_clock::time_point>>(value);
  }
  inline bool has_value_std__optional_std__variant_std__string__double__bool__std__chrono__system_clock__time_point__(const std::optional<std::variant<std::string, double, bool, std::chrono::system_clock::time_point>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<std::string, double, bool, std::chrono::system_clock::time_point> get_std__optional_std__variant_std__string__double__bool__std__chrono__system_clock__time_point__(const std::optional<std::variant<std::string, double, bool, std::chrono::system_clock::time_point>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<std::chrono::system_clock::time_point>
  /**
   * Specialized version of `std::optional<std::chrono::system_clock::time_point>`.
   */
  using std__optional_std__chrono__system_clock__time_point_ = std::optional<std::chrono::system_clock::time_point>;
  inline std::optional<std::chrono::system_clock::time_point> create_std__optional_std__chrono__system_clock__time_point_(const std::chrono::system_clock::time_point& value) noexcept {
    return std::optional<std::chrono::system_clock::time_point>(value);
  }
  inline bool has_value_std__optional_std__chrono__system_clock__time_point_(const std::optional<std::chrono::system_clock::time_point>& optional) noexcept {
    return optional.has_value();
  }
  inline std::chrono::system_clock::time_point get_std__optional_std__chrono__system_clock__time_point_(const std::optional<std::chrono::system_clock::time_point>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::shared_ptr<HybridWorkoutProxySpec>
  /**
   * Specialized version of `std::shared_ptr<HybridWorkoutProxySpec>`.
   */
  using std__shared_ptr_HybridWorkoutProxySpec_ = std::shared_ptr<HybridWorkoutProxySpec>;
  std::shared_ptr<HybridWorkoutProxySpec> create_std__shared_ptr_HybridWorkoutProxySpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridWorkoutProxySpec_(std__shared_ptr_HybridWorkoutProxySpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridWorkoutProxySpec>
  using std__weak_ptr_HybridWorkoutProxySpec_ = std::weak_ptr<HybridWorkoutProxySpec>;
  inline std__weak_ptr_HybridWorkoutProxySpec_ weakify_std__shared_ptr_HybridWorkoutProxySpec_(const std::shared_ptr<HybridWorkoutProxySpec>& strong) noexcept { return strong; }
  
  // pragma MARK: std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout>
  /**
   * Wrapper struct for `std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout_ {
    std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout> variant;
    std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout_(std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout> variant): variant(variant) { }
    operator std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline PredicateWithUUID get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline PredicateWithUUIDs get_1() const noexcept {
      return std::get<1>(variant);
    }
    inline PredicateWithMetadataKey get_2() const noexcept {
      return std::get<2>(variant);
    }
    inline PredicateWithStartAndEnd get_3() const noexcept {
      return std::get<3>(variant);
    }
    inline PredicateFromWorkout get_4() const noexcept {
      return std::get<4>(variant);
    }
  };
  inline std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout_ create_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout_(const PredicateWithUUID& value) noexcept {
    return std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout_(value);
  }
  inline std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout_ create_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout_(const PredicateWithUUIDs& value) noexcept {
    return std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout_(value);
  }
  inline std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout_ create_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout_(const PredicateWithMetadataKey& value) noexcept {
    return std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout_(value);
  }
  inline std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout_ create_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout_(const PredicateWithStartAndEnd& value) noexcept {
    return std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout_(value);
  }
  inline std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout_ create_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout_(const PredicateFromWorkout& value) noexcept {
    return std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout_(value);
  }
  
  // pragma MARK: std::vector<std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout>>
  /**
   * Specialized version of `std::vector<std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout>>`.
   */
  using std__vector_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__ = std::vector<std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout>>;
  inline std::vector<std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout>> create_std__vector_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__(size_t size) noexcept {
    std::vector<std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout>> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, FilterForSamplesAnd, FilterForSamplesOr>
  /**
   * Wrapper struct for `std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, FilterForSamplesAnd, FilterForSamplesOr>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__FilterForSamplesAnd__FilterForSamplesOr_ {
    std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, FilterForSamplesAnd, FilterForSamplesOr> variant;
    std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__FilterForSamplesAnd__FilterForSamplesOr_(std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, FilterForSamplesAnd, FilterForSamplesOr> variant): variant(variant) { }
    operator std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, FilterForSamplesAnd, FilterForSamplesOr>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline PredicateWithUUID get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline PredicateWithUUIDs get_1() const noexcept {
      return std::get<1>(variant);
    }
    inline PredicateWithMetadataKey get_2() const noexcept {
      return std::get<2>(variant);
    }
    inline PredicateWithStartAndEnd get_3() const noexcept {
      return std::get<3>(variant);
    }
    inline PredicateFromWorkout get_4() const noexcept {
      return std::get<4>(variant);
    }
    inline FilterForSamplesAnd get_5() const noexcept {
      return std::get<5>(variant);
    }
    inline FilterForSamplesOr get_6() const noexcept {
      return std::get<6>(variant);
    }
  };
  inline std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__FilterForSamplesAnd__FilterForSamplesOr_ create_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__FilterForSamplesAnd__FilterForSamplesOr_(const PredicateWithUUID& value) noexcept {
    return std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__FilterForSamplesAnd__FilterForSamplesOr_(value);
  }
  inline std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__FilterForSamplesAnd__FilterForSamplesOr_ create_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__FilterForSamplesAnd__FilterForSamplesOr_(const PredicateWithUUIDs& value) noexcept {
    return std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__FilterForSamplesAnd__FilterForSamplesOr_(value);
  }
  inline std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__FilterForSamplesAnd__FilterForSamplesOr_ create_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__FilterForSamplesAnd__FilterForSamplesOr_(const PredicateWithMetadataKey& value) noexcept {
    return std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__FilterForSamplesAnd__FilterForSamplesOr_(value);
  }
  inline std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__FilterForSamplesAnd__FilterForSamplesOr_ create_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__FilterForSamplesAnd__FilterForSamplesOr_(const PredicateWithStartAndEnd& value) noexcept {
    return std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__FilterForSamplesAnd__FilterForSamplesOr_(value);
  }
  inline std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__FilterForSamplesAnd__FilterForSamplesOr_ create_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__FilterForSamplesAnd__FilterForSamplesOr_(const PredicateFromWorkout& value) noexcept {
    return std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__FilterForSamplesAnd__FilterForSamplesOr_(value);
  }
  inline std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__FilterForSamplesAnd__FilterForSamplesOr_ create_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__FilterForSamplesAnd__FilterForSamplesOr_(const FilterForSamplesAnd& value) noexcept {
    return std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__FilterForSamplesAnd__FilterForSamplesOr_(value);
  }
  inline std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__FilterForSamplesAnd__FilterForSamplesOr_ create_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__FilterForSamplesAnd__FilterForSamplesOr_(const FilterForSamplesOr& value) noexcept {
    return std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__FilterForSamplesAnd__FilterForSamplesOr_(value);
  }
  
  // pragma MARK: std::optional<std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, FilterForSamplesAnd, FilterForSamplesOr>>
  /**
   * Specialized version of `std::optional<std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, FilterForSamplesAnd, FilterForSamplesOr>>`.
   */
  using std__optional_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__FilterForSamplesAnd__FilterForSamplesOr__ = std::optional<std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, FilterForSamplesAnd, FilterForSamplesOr>>;
  inline std::optional<std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, FilterForSamplesAnd, FilterForSamplesOr>> create_std__optional_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__FilterForSamplesAnd__FilterForSamplesOr__(const std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, FilterForSamplesAnd, FilterForSamplesOr>& value) noexcept {
    return std::optional<std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, FilterForSamplesAnd, FilterForSamplesOr>>(value);
  }
  inline bool has_value_std__optional_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__FilterForSamplesAnd__FilterForSamplesOr__(const std::optional<std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, FilterForSamplesAnd, FilterForSamplesOr>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, FilterForSamplesAnd, FilterForSamplesOr> get_std__optional_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__FilterForSamplesAnd__FilterForSamplesOr__(const std::optional<std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, FilterForSamplesAnd, FilterForSamplesOr>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<double>
  /**
   * Specialized version of `std::optional<double>`.
   */
  using std__optional_double_ = std::optional<double>;
  inline std::optional<double> create_std__optional_double_(const double& value) noexcept {
    return std::optional<double>(value);
  }
  inline bool has_value_std__optional_double_(const std::optional<double>& optional) noexcept {
    return optional.has_value();
  }
  inline double get_std__optional_double_(const std::optional<double>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<QueryOptionsWithSortOrder>
  /**
   * Specialized version of `std::optional<QueryOptionsWithSortOrder>`.
   */
  using std__optional_QueryOptionsWithSortOrder_ = std::optional<QueryOptionsWithSortOrder>;
  inline std::optional<QueryOptionsWithSortOrder> create_std__optional_QueryOptionsWithSortOrder_(const QueryOptionsWithSortOrder& value) noexcept {
    return std::optional<QueryOptionsWithSortOrder>(value);
  }
  inline bool has_value_std__optional_QueryOptionsWithSortOrder_(const std::optional<QueryOptionsWithSortOrder>& optional) noexcept {
    return optional.has_value();
  }
  inline QueryOptionsWithSortOrder get_std__optional_QueryOptionsWithSortOrder_(const std::optional<QueryOptionsWithSortOrder>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<std::shared_ptr<AnyMap>>
  /**
   * Specialized version of `std::optional<std::shared_ptr<AnyMap>>`.
   */
  using std__optional_std__shared_ptr_AnyMap__ = std::optional<std::shared_ptr<AnyMap>>;
  inline std::optional<std::shared_ptr<AnyMap>> create_std__optional_std__shared_ptr_AnyMap__(const std::shared_ptr<AnyMap>& value) noexcept {
    return std::optional<std::shared_ptr<AnyMap>>(value);
  }
  inline bool has_value_std__optional_std__shared_ptr_AnyMap__(const std::optional<std::shared_ptr<AnyMap>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::shared_ptr<AnyMap> get_std__optional_std__shared_ptr_AnyMap__(const std::optional<std::shared_ptr<AnyMap>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<DeletedSample>
  /**
   * Specialized version of `std::vector<DeletedSample>`.
   */
  using std__vector_DeletedSample_ = std::vector<DeletedSample>;
  inline std::vector<DeletedSample> create_std__vector_DeletedSample_(size_t size) noexcept {
    std::vector<DeletedSample> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::shared_ptr<Promise<CategorySamplesWithAnchorResponse>>
  /**
   * Specialized version of `std::shared_ptr<Promise<CategorySamplesWithAnchorResponse>>`.
   */
  using std__shared_ptr_Promise_CategorySamplesWithAnchorResponse__ = std::shared_ptr<Promise<CategorySamplesWithAnchorResponse>>;
  inline std::shared_ptr<Promise<CategorySamplesWithAnchorResponse>> create_std__shared_ptr_Promise_CategorySamplesWithAnchorResponse__() noexcept {
    return Promise<CategorySamplesWithAnchorResponse>::create();
  }
  inline PromiseHolder<CategorySamplesWithAnchorResponse> wrap_std__shared_ptr_Promise_CategorySamplesWithAnchorResponse__(std::shared_ptr<Promise<CategorySamplesWithAnchorResponse>> promise) noexcept {
    return PromiseHolder<CategorySamplesWithAnchorResponse>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const CategorySamplesWithAnchorResponse& /* result */)>
  /**
   * Specialized version of `std::function<void(const CategorySamplesWithAnchorResponse&)>`.
   */
  using Func_void_CategorySamplesWithAnchorResponse = std::function<void(const CategorySamplesWithAnchorResponse& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const CategorySamplesWithAnchorResponse& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_CategorySamplesWithAnchorResponse_Wrapper final {
  public:
    explicit Func_void_CategorySamplesWithAnchorResponse_Wrapper(std::function<void(const CategorySamplesWithAnchorResponse& /* result */)>&& func): _function(std::make_unique<std::function<void(const CategorySamplesWithAnchorResponse& /* result */)>>(std::move(func))) {}
    inline void call(CategorySamplesWithAnchorResponse result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const CategorySamplesWithAnchorResponse& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_CategorySamplesWithAnchorResponse create_Func_void_CategorySamplesWithAnchorResponse(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_CategorySamplesWithAnchorResponse_Wrapper wrap_Func_void_CategorySamplesWithAnchorResponse(Func_void_CategorySamplesWithAnchorResponse value) noexcept {
    return Func_void_CategorySamplesWithAnchorResponse_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<HybridCategoryTypeModuleSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridCategoryTypeModuleSpec>`.
   */
  using std__shared_ptr_HybridCategoryTypeModuleSpec_ = std::shared_ptr<HybridCategoryTypeModuleSpec>;
  std::shared_ptr<HybridCategoryTypeModuleSpec> create_std__shared_ptr_HybridCategoryTypeModuleSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridCategoryTypeModuleSpec_(std__shared_ptr_HybridCategoryTypeModuleSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridCategoryTypeModuleSpec>
  using std__weak_ptr_HybridCategoryTypeModuleSpec_ = std::weak_ptr<HybridCategoryTypeModuleSpec>;
  inline std__weak_ptr_HybridCategoryTypeModuleSpec_ weakify_std__shared_ptr_HybridCategoryTypeModuleSpec_(const std::shared_ptr<HybridCategoryTypeModuleSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: Result<std::shared_ptr<Promise<bool>>>
  using Result_std__shared_ptr_Promise_bool___ = Result<std::shared_ptr<Promise<bool>>>;
  inline Result_std__shared_ptr_Promise_bool___ create_Result_std__shared_ptr_Promise_bool___(const std::shared_ptr<Promise<bool>>& value) noexcept {
    return Result<std::shared_ptr<Promise<bool>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_bool___ create_Result_std__shared_ptr_Promise_bool___(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<bool>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::vector<CategorySample>>>>
  using Result_std__shared_ptr_Promise_std__vector_CategorySample____ = Result<std::shared_ptr<Promise<std::vector<CategorySample>>>>;
  inline Result_std__shared_ptr_Promise_std__vector_CategorySample____ create_Result_std__shared_ptr_Promise_std__vector_CategorySample____(const std::shared_ptr<Promise<std::vector<CategorySample>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<CategorySample>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__vector_CategorySample____ create_Result_std__shared_ptr_Promise_std__vector_CategorySample____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<CategorySample>>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<CategorySamplesWithAnchorResponse>>>
  using Result_std__shared_ptr_Promise_CategorySamplesWithAnchorResponse___ = Result<std::shared_ptr<Promise<CategorySamplesWithAnchorResponse>>>;
  inline Result_std__shared_ptr_Promise_CategorySamplesWithAnchorResponse___ create_Result_std__shared_ptr_Promise_CategorySamplesWithAnchorResponse___(const std::shared_ptr<Promise<CategorySamplesWithAnchorResponse>>& value) noexcept {
    return Result<std::shared_ptr<Promise<CategorySamplesWithAnchorResponse>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_CategorySamplesWithAnchorResponse___ create_Result_std__shared_ptr_Promise_CategorySamplesWithAnchorResponse___(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<CategorySamplesWithAnchorResponse>>>::withError(error);
  }
  
  // pragma MARK: std::shared_ptr<Promise<BloodType>>
  /**
   * Specialized version of `std::shared_ptr<Promise<BloodType>>`.
   */
  using std__shared_ptr_Promise_BloodType__ = std::shared_ptr<Promise<BloodType>>;
  inline std::shared_ptr<Promise<BloodType>> create_std__shared_ptr_Promise_BloodType__() noexcept {
    return Promise<BloodType>::create();
  }
  inline PromiseHolder<BloodType> wrap_std__shared_ptr_Promise_BloodType__(std::shared_ptr<Promise<BloodType>> promise) noexcept {
    return PromiseHolder<BloodType>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(BloodType /* result */)>
  /**
   * Specialized version of `std::function<void(BloodType)>`.
   */
  using Func_void_BloodType = std::function<void(BloodType /* result */)>;
  /**
   * Wrapper class for a `std::function<void(BloodType / * result * /)>`, this can be used from Swift.
   */
  class Func_void_BloodType_Wrapper final {
  public:
    explicit Func_void_BloodType_Wrapper(std::function<void(BloodType /* result */)>&& func): _function(std::make_unique<std::function<void(BloodType /* result */)>>(std::move(func))) {}
    inline void call(int result) const noexcept {
      _function->operator()(static_cast<BloodType>(result));
    }
  private:
    std::unique_ptr<std::function<void(BloodType /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_BloodType create_Func_void_BloodType(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_BloodType_Wrapper wrap_Func_void_BloodType(Func_void_BloodType value) noexcept {
    return Func_void_BloodType_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::optional<std::chrono::system_clock::time_point>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::optional<std::chrono::system_clock::time_point>>>`.
   */
  using std__shared_ptr_Promise_std__optional_std__chrono__system_clock__time_point___ = std::shared_ptr<Promise<std::optional<std::chrono::system_clock::time_point>>>;
  inline std::shared_ptr<Promise<std::optional<std::chrono::system_clock::time_point>>> create_std__shared_ptr_Promise_std__optional_std__chrono__system_clock__time_point___() noexcept {
    return Promise<std::optional<std::chrono::system_clock::time_point>>::create();
  }
  inline PromiseHolder<std::optional<std::chrono::system_clock::time_point>> wrap_std__shared_ptr_Promise_std__optional_std__chrono__system_clock__time_point___(std::shared_ptr<Promise<std::optional<std::chrono::system_clock::time_point>>> promise) noexcept {
    return PromiseHolder<std::optional<std::chrono::system_clock::time_point>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(std::optional<std::chrono::system_clock::time_point> /* result */)>
  /**
   * Specialized version of `std::function<void(std::optional<std::chrono::system_clock::time_point>)>`.
   */
  using Func_void_std__optional_std__chrono__system_clock__time_point_ = std::function<void(std::optional<std::chrono::system_clock::time_point> /* result */)>;
  /**
   * Wrapper class for a `std::function<void(std::optional<std::chrono::system_clock::time_point> / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__optional_std__chrono__system_clock__time_point__Wrapper final {
  public:
    explicit Func_void_std__optional_std__chrono__system_clock__time_point__Wrapper(std::function<void(std::optional<std::chrono::system_clock::time_point> /* result */)>&& func): _function(std::make_unique<std::function<void(std::optional<std::chrono::system_clock::time_point> /* result */)>>(std::move(func))) {}
    inline void call(std::optional<std::chrono::system_clock::time_point> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(std::optional<std::chrono::system_clock::time_point> /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__optional_std__chrono__system_clock__time_point_ create_Func_void_std__optional_std__chrono__system_clock__time_point_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__optional_std__chrono__system_clock__time_point__Wrapper wrap_Func_void_std__optional_std__chrono__system_clock__time_point_(Func_void_std__optional_std__chrono__system_clock__time_point_ value) noexcept {
    return Func_void_std__optional_std__chrono__system_clock__time_point__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<Promise<BiologicalSex>>
  /**
   * Specialized version of `std::shared_ptr<Promise<BiologicalSex>>`.
   */
  using std__shared_ptr_Promise_BiologicalSex__ = std::shared_ptr<Promise<BiologicalSex>>;
  inline std::shared_ptr<Promise<BiologicalSex>> create_std__shared_ptr_Promise_BiologicalSex__() noexcept {
    return Promise<BiologicalSex>::create();
  }
  inline PromiseHolder<BiologicalSex> wrap_std__shared_ptr_Promise_BiologicalSex__(std::shared_ptr<Promise<BiologicalSex>> promise) noexcept {
    return PromiseHolder<BiologicalSex>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(BiologicalSex /* result */)>
  /**
   * Specialized version of `std::function<void(BiologicalSex)>`.
   */
  using Func_void_BiologicalSex = std::function<void(BiologicalSex /* result */)>;
  /**
   * Wrapper class for a `std::function<void(BiologicalSex / * result * /)>`, this can be used from Swift.
   */
  class Func_void_BiologicalSex_Wrapper final {
  public:
    explicit Func_void_BiologicalSex_Wrapper(std::function<void(BiologicalSex /* result */)>&& func): _function(std::make_unique<std::function<void(BiologicalSex /* result */)>>(std::move(func))) {}
    inline void call(int result) const noexcept {
      _function->operator()(static_cast<BiologicalSex>(result));
    }
  private:
    std::unique_ptr<std::function<void(BiologicalSex /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_BiologicalSex create_Func_void_BiologicalSex(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_BiologicalSex_Wrapper wrap_Func_void_BiologicalSex(Func_void_BiologicalSex value) noexcept {
    return Func_void_BiologicalSex_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<Promise<FitzpatrickSkinType>>
  /**
   * Specialized version of `std::shared_ptr<Promise<FitzpatrickSkinType>>`.
   */
  using std__shared_ptr_Promise_FitzpatrickSkinType__ = std::shared_ptr<Promise<FitzpatrickSkinType>>;
  inline std::shared_ptr<Promise<FitzpatrickSkinType>> create_std__shared_ptr_Promise_FitzpatrickSkinType__() noexcept {
    return Promise<FitzpatrickSkinType>::create();
  }
  inline PromiseHolder<FitzpatrickSkinType> wrap_std__shared_ptr_Promise_FitzpatrickSkinType__(std::shared_ptr<Promise<FitzpatrickSkinType>> promise) noexcept {
    return PromiseHolder<FitzpatrickSkinType>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(FitzpatrickSkinType /* result */)>
  /**
   * Specialized version of `std::function<void(FitzpatrickSkinType)>`.
   */
  using Func_void_FitzpatrickSkinType = std::function<void(FitzpatrickSkinType /* result */)>;
  /**
   * Wrapper class for a `std::function<void(FitzpatrickSkinType / * result * /)>`, this can be used from Swift.
   */
  class Func_void_FitzpatrickSkinType_Wrapper final {
  public:
    explicit Func_void_FitzpatrickSkinType_Wrapper(std::function<void(FitzpatrickSkinType /* result */)>&& func): _function(std::make_unique<std::function<void(FitzpatrickSkinType /* result */)>>(std::move(func))) {}
    inline void call(int result) const noexcept {
      _function->operator()(static_cast<FitzpatrickSkinType>(result));
    }
  private:
    std::unique_ptr<std::function<void(FitzpatrickSkinType /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_FitzpatrickSkinType create_Func_void_FitzpatrickSkinType(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_FitzpatrickSkinType_Wrapper wrap_Func_void_FitzpatrickSkinType(Func_void_FitzpatrickSkinType value) noexcept {
    return Func_void_FitzpatrickSkinType_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<Promise<WheelchairUse>>
  /**
   * Specialized version of `std::shared_ptr<Promise<WheelchairUse>>`.
   */
  using std__shared_ptr_Promise_WheelchairUse__ = std::shared_ptr<Promise<WheelchairUse>>;
  inline std::shared_ptr<Promise<WheelchairUse>> create_std__shared_ptr_Promise_WheelchairUse__() noexcept {
    return Promise<WheelchairUse>::create();
  }
  inline PromiseHolder<WheelchairUse> wrap_std__shared_ptr_Promise_WheelchairUse__(std::shared_ptr<Promise<WheelchairUse>> promise) noexcept {
    return PromiseHolder<WheelchairUse>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(WheelchairUse /* result */)>
  /**
   * Specialized version of `std::function<void(WheelchairUse)>`.
   */
  using Func_void_WheelchairUse = std::function<void(WheelchairUse /* result */)>;
  /**
   * Wrapper class for a `std::function<void(WheelchairUse / * result * /)>`, this can be used from Swift.
   */
  class Func_void_WheelchairUse_Wrapper final {
  public:
    explicit Func_void_WheelchairUse_Wrapper(std::function<void(WheelchairUse /* result */)>&& func): _function(std::make_unique<std::function<void(WheelchairUse /* result */)>>(std::move(func))) {}
    inline void call(int result) const noexcept {
      _function->operator()(static_cast<WheelchairUse>(result));
    }
  private:
    std::unique_ptr<std::function<void(WheelchairUse /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_WheelchairUse create_Func_void_WheelchairUse(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_WheelchairUse_Wrapper wrap_Func_void_WheelchairUse(Func_void_WheelchairUse value) noexcept {
    return Func_void_WheelchairUse_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<HybridCharacteristicTypeModuleSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridCharacteristicTypeModuleSpec>`.
   */
  using std__shared_ptr_HybridCharacteristicTypeModuleSpec_ = std::shared_ptr<HybridCharacteristicTypeModuleSpec>;
  std::shared_ptr<HybridCharacteristicTypeModuleSpec> create_std__shared_ptr_HybridCharacteristicTypeModuleSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridCharacteristicTypeModuleSpec_(std__shared_ptr_HybridCharacteristicTypeModuleSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridCharacteristicTypeModuleSpec>
  using std__weak_ptr_HybridCharacteristicTypeModuleSpec_ = std::weak_ptr<HybridCharacteristicTypeModuleSpec>;
  inline std__weak_ptr_HybridCharacteristicTypeModuleSpec_ weakify_std__shared_ptr_HybridCharacteristicTypeModuleSpec_(const std::shared_ptr<HybridCharacteristicTypeModuleSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: Result<BloodType>
  using Result_BloodType_ = Result<BloodType>;
  inline Result_BloodType_ create_Result_BloodType_(BloodType value) noexcept {
    return Result<BloodType>::withValue(std::move(value));
  }
  inline Result_BloodType_ create_Result_BloodType_(const std::exception_ptr& error) noexcept {
    return Result<BloodType>::withError(error);
  }
  
  // pragma MARK: Result<std::optional<std::chrono::system_clock::time_point>>
  using Result_std__optional_std__chrono__system_clock__time_point__ = Result<std::optional<std::chrono::system_clock::time_point>>;
  inline Result_std__optional_std__chrono__system_clock__time_point__ create_Result_std__optional_std__chrono__system_clock__time_point__(std::optional<std::chrono::system_clock::time_point> value) noexcept {
    return Result<std::optional<std::chrono::system_clock::time_point>>::withValue(std::move(value));
  }
  inline Result_std__optional_std__chrono__system_clock__time_point__ create_Result_std__optional_std__chrono__system_clock__time_point__(const std::exception_ptr& error) noexcept {
    return Result<std::optional<std::chrono::system_clock::time_point>>::withError(error);
  }
  
  // pragma MARK: Result<BiologicalSex>
  using Result_BiologicalSex_ = Result<BiologicalSex>;
  inline Result_BiologicalSex_ create_Result_BiologicalSex_(BiologicalSex value) noexcept {
    return Result<BiologicalSex>::withValue(std::move(value));
  }
  inline Result_BiologicalSex_ create_Result_BiologicalSex_(const std::exception_ptr& error) noexcept {
    return Result<BiologicalSex>::withError(error);
  }
  
  // pragma MARK: Result<FitzpatrickSkinType>
  using Result_FitzpatrickSkinType_ = Result<FitzpatrickSkinType>;
  inline Result_FitzpatrickSkinType_ create_Result_FitzpatrickSkinType_(FitzpatrickSkinType value) noexcept {
    return Result<FitzpatrickSkinType>::withValue(std::move(value));
  }
  inline Result_FitzpatrickSkinType_ create_Result_FitzpatrickSkinType_(const std::exception_ptr& error) noexcept {
    return Result<FitzpatrickSkinType>::withError(error);
  }
  
  // pragma MARK: Result<WheelchairUse>
  using Result_WheelchairUse_ = Result<WheelchairUse>;
  inline Result_WheelchairUse_ create_Result_WheelchairUse_(WheelchairUse value) noexcept {
    return Result<WheelchairUse>::withValue(std::move(value));
  }
  inline Result_WheelchairUse_ create_Result_WheelchairUse_(const std::exception_ptr& error) noexcept {
    return Result<WheelchairUse>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<BloodType>>>
  using Result_std__shared_ptr_Promise_BloodType___ = Result<std::shared_ptr<Promise<BloodType>>>;
  inline Result_std__shared_ptr_Promise_BloodType___ create_Result_std__shared_ptr_Promise_BloodType___(const std::shared_ptr<Promise<BloodType>>& value) noexcept {
    return Result<std::shared_ptr<Promise<BloodType>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_BloodType___ create_Result_std__shared_ptr_Promise_BloodType___(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<BloodType>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::optional<std::chrono::system_clock::time_point>>>>
  using Result_std__shared_ptr_Promise_std__optional_std__chrono__system_clock__time_point____ = Result<std::shared_ptr<Promise<std::optional<std::chrono::system_clock::time_point>>>>;
  inline Result_std__shared_ptr_Promise_std__optional_std__chrono__system_clock__time_point____ create_Result_std__shared_ptr_Promise_std__optional_std__chrono__system_clock__time_point____(const std::shared_ptr<Promise<std::optional<std::chrono::system_clock::time_point>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::optional<std::chrono::system_clock::time_point>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__optional_std__chrono__system_clock__time_point____ create_Result_std__shared_ptr_Promise_std__optional_std__chrono__system_clock__time_point____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::optional<std::chrono::system_clock::time_point>>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<BiologicalSex>>>
  using Result_std__shared_ptr_Promise_BiologicalSex___ = Result<std::shared_ptr<Promise<BiologicalSex>>>;
  inline Result_std__shared_ptr_Promise_BiologicalSex___ create_Result_std__shared_ptr_Promise_BiologicalSex___(const std::shared_ptr<Promise<BiologicalSex>>& value) noexcept {
    return Result<std::shared_ptr<Promise<BiologicalSex>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_BiologicalSex___ create_Result_std__shared_ptr_Promise_BiologicalSex___(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<BiologicalSex>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<FitzpatrickSkinType>>>
  using Result_std__shared_ptr_Promise_FitzpatrickSkinType___ = Result<std::shared_ptr<Promise<FitzpatrickSkinType>>>;
  inline Result_std__shared_ptr_Promise_FitzpatrickSkinType___ create_Result_std__shared_ptr_Promise_FitzpatrickSkinType___(const std::shared_ptr<Promise<FitzpatrickSkinType>>& value) noexcept {
    return Result<std::shared_ptr<Promise<FitzpatrickSkinType>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_FitzpatrickSkinType___ create_Result_std__shared_ptr_Promise_FitzpatrickSkinType___(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<FitzpatrickSkinType>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<WheelchairUse>>>
  using Result_std__shared_ptr_Promise_WheelchairUse___ = Result<std::shared_ptr<Promise<WheelchairUse>>>;
  inline Result_std__shared_ptr_Promise_WheelchairUse___ create_Result_std__shared_ptr_Promise_WheelchairUse___(const std::shared_ptr<Promise<WheelchairUse>>& value) noexcept {
    return Result<std::shared_ptr<Promise<WheelchairUse>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_WheelchairUse___ create_Result_std__shared_ptr_Promise_WheelchairUse___(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<WheelchairUse>>>::withError(error);
  }
  
  // pragma MARK: std::vector<IdentifierWithUnit>
  /**
   * Specialized version of `std::vector<IdentifierWithUnit>`.
   */
  using std__vector_IdentifierWithUnit_ = std::vector<IdentifierWithUnit>;
  inline std::vector<IdentifierWithUnit> create_std__vector_IdentifierWithUnit_(size_t size) noexcept {
    std::vector<IdentifierWithUnit> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::vector<IdentifierWithUnit>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::vector<IdentifierWithUnit>>>`.
   */
  using std__shared_ptr_Promise_std__vector_IdentifierWithUnit___ = std::shared_ptr<Promise<std::vector<IdentifierWithUnit>>>;
  inline std::shared_ptr<Promise<std::vector<IdentifierWithUnit>>> create_std__shared_ptr_Promise_std__vector_IdentifierWithUnit___() noexcept {
    return Promise<std::vector<IdentifierWithUnit>>::create();
  }
  inline PromiseHolder<std::vector<IdentifierWithUnit>> wrap_std__shared_ptr_Promise_std__vector_IdentifierWithUnit___(std::shared_ptr<Promise<std::vector<IdentifierWithUnit>>> promise) noexcept {
    return PromiseHolder<std::vector<IdentifierWithUnit>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::vector<IdentifierWithUnit>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::vector<IdentifierWithUnit>&)>`.
   */
  using Func_void_std__vector_IdentifierWithUnit_ = std::function<void(const std::vector<IdentifierWithUnit>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::vector<IdentifierWithUnit>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__vector_IdentifierWithUnit__Wrapper final {
  public:
    explicit Func_void_std__vector_IdentifierWithUnit__Wrapper(std::function<void(const std::vector<IdentifierWithUnit>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::vector<IdentifierWithUnit>& /* result */)>>(std::move(func))) {}
    inline void call(std::vector<IdentifierWithUnit> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::vector<IdentifierWithUnit>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__vector_IdentifierWithUnit_ create_Func_void_std__vector_IdentifierWithUnit_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__vector_IdentifierWithUnit__Wrapper wrap_Func_void_std__vector_IdentifierWithUnit_(Func_void_std__vector_IdentifierWithUnit_ value) noexcept {
    return Func_void_std__vector_IdentifierWithUnit__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::vector<QuantityTypeIdentifier>
  /**
   * Specialized version of `std::vector<QuantityTypeIdentifier>`.
   */
  using std__vector_QuantityTypeIdentifier_ = std::vector<QuantityTypeIdentifier>;
  inline std::vector<QuantityTypeIdentifier> copy_std__vector_QuantityTypeIdentifier_(const QuantityTypeIdentifier* CONTIGUOUS_MEMORY NON_NULL data, size_t size) noexcept {
    return margelo::nitro::FastVectorCopy<QuantityTypeIdentifier>(data, size);
  }
  inline const QuantityTypeIdentifier* CONTIGUOUS_MEMORY NON_NULL get_data_std__vector_QuantityTypeIdentifier_(const std::vector<QuantityTypeIdentifier>& vector) noexcept {
    return vector.data();
  }
  
  // pragma MARK: std::vector<std::shared_ptr<HybridSourceProxySpec>>
  /**
   * Specialized version of `std::vector<std::shared_ptr<HybridSourceProxySpec>>`.
   */
  using std__vector_std__shared_ptr_HybridSourceProxySpec__ = std::vector<std::shared_ptr<HybridSourceProxySpec>>;
  inline std::vector<std::shared_ptr<HybridSourceProxySpec>> create_std__vector_std__shared_ptr_HybridSourceProxySpec__(size_t size) noexcept {
    std::vector<std::shared_ptr<HybridSourceProxySpec>> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::vector<std::shared_ptr<HybridSourceProxySpec>>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::vector<std::shared_ptr<HybridSourceProxySpec>>>>`.
   */
  using std__shared_ptr_Promise_std__vector_std__shared_ptr_HybridSourceProxySpec____ = std::shared_ptr<Promise<std::vector<std::shared_ptr<HybridSourceProxySpec>>>>;
  inline std::shared_ptr<Promise<std::vector<std::shared_ptr<HybridSourceProxySpec>>>> create_std__shared_ptr_Promise_std__vector_std__shared_ptr_HybridSourceProxySpec____() noexcept {
    return Promise<std::vector<std::shared_ptr<HybridSourceProxySpec>>>::create();
  }
  inline PromiseHolder<std::vector<std::shared_ptr<HybridSourceProxySpec>>> wrap_std__shared_ptr_Promise_std__vector_std__shared_ptr_HybridSourceProxySpec____(std::shared_ptr<Promise<std::vector<std::shared_ptr<HybridSourceProxySpec>>>> promise) noexcept {
    return PromiseHolder<std::vector<std::shared_ptr<HybridSourceProxySpec>>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::vector<std::shared_ptr<HybridSourceProxySpec>>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::vector<std::shared_ptr<HybridSourceProxySpec>>&)>`.
   */
  using Func_void_std__vector_std__shared_ptr_HybridSourceProxySpec__ = std::function<void(const std::vector<std::shared_ptr<HybridSourceProxySpec>>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::vector<std::shared_ptr<HybridSourceProxySpec>>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__vector_std__shared_ptr_HybridSourceProxySpec___Wrapper final {
  public:
    explicit Func_void_std__vector_std__shared_ptr_HybridSourceProxySpec___Wrapper(std::function<void(const std::vector<std::shared_ptr<HybridSourceProxySpec>>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::vector<std::shared_ptr<HybridSourceProxySpec>>& /* result */)>>(std::move(func))) {}
    inline void call(std::vector<std::shared_ptr<HybridSourceProxySpec>> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::vector<std::shared_ptr<HybridSourceProxySpec>>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__vector_std__shared_ptr_HybridSourceProxySpec__ create_Func_void_std__vector_std__shared_ptr_HybridSourceProxySpec__(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__vector_std__shared_ptr_HybridSourceProxySpec___Wrapper wrap_Func_void_std__vector_std__shared_ptr_HybridSourceProxySpec__(Func_void_std__vector_std__shared_ptr_HybridSourceProxySpec__ value) noexcept {
    return Func_void_std__vector_std__shared_ptr_HybridSourceProxySpec___Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const OnChangeCallbackArgs& /* args */)>
  /**
   * Specialized version of `std::function<void(const OnChangeCallbackArgs&)>`.
   */
  using Func_void_OnChangeCallbackArgs = std::function<void(const OnChangeCallbackArgs& /* args */)>;
  /**
   * Wrapper class for a `std::function<void(const OnChangeCallbackArgs& / * args * /)>`, this can be used from Swift.
   */
  class Func_void_OnChangeCallbackArgs_Wrapper final {
  public:
    explicit Func_void_OnChangeCallbackArgs_Wrapper(std::function<void(const OnChangeCallbackArgs& /* args */)>&& func): _function(std::make_unique<std::function<void(const OnChangeCallbackArgs& /* args */)>>(std::move(func))) {}
    inline void call(OnChangeCallbackArgs args) const noexcept {
      _function->operator()(args);
    }
  private:
    std::unique_ptr<std::function<void(const OnChangeCallbackArgs& /* args */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_OnChangeCallbackArgs create_Func_void_OnChangeCallbackArgs(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_OnChangeCallbackArgs_Wrapper wrap_Func_void_OnChangeCallbackArgs(Func_void_OnChangeCallbackArgs value) noexcept {
    return Func_void_OnChangeCallbackArgs_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<Promise<double>>
  /**
   * Specialized version of `std::shared_ptr<Promise<double>>`.
   */
  using std__shared_ptr_Promise_double__ = std::shared_ptr<Promise<double>>;
  inline std::shared_ptr<Promise<double>> create_std__shared_ptr_Promise_double__() noexcept {
    return Promise<double>::create();
  }
  inline PromiseHolder<double> wrap_std__shared_ptr_Promise_double__(std::shared_ptr<Promise<double>> promise) noexcept {
    return PromiseHolder<double>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(double /* result */)>
  /**
   * Specialized version of `std::function<void(double)>`.
   */
  using Func_void_double = std::function<void(double /* result */)>;
  /**
   * Wrapper class for a `std::function<void(double / * result * /)>`, this can be used from Swift.
   */
  class Func_void_double_Wrapper final {
  public:
    explicit Func_void_double_Wrapper(std::function<void(double /* result */)>&& func): _function(std::make_unique<std::function<void(double /* result */)>>(std::move(func))) {}
    inline void call(double result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(double /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_double create_Func_void_double(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_double_Wrapper wrap_Func_void_double(Func_void_double value) noexcept {
    return Func_void_double_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<Promise<AuthorizationRequestStatus>>
  /**
   * Specialized version of `std::shared_ptr<Promise<AuthorizationRequestStatus>>`.
   */
  using std__shared_ptr_Promise_AuthorizationRequestStatus__ = std::shared_ptr<Promise<AuthorizationRequestStatus>>;
  inline std::shared_ptr<Promise<AuthorizationRequestStatus>> create_std__shared_ptr_Promise_AuthorizationRequestStatus__() noexcept {
    return Promise<AuthorizationRequestStatus>::create();
  }
  inline PromiseHolder<AuthorizationRequestStatus> wrap_std__shared_ptr_Promise_AuthorizationRequestStatus__(std::shared_ptr<Promise<AuthorizationRequestStatus>> promise) noexcept {
    return PromiseHolder<AuthorizationRequestStatus>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(AuthorizationRequestStatus /* result */)>
  /**
   * Specialized version of `std::function<void(AuthorizationRequestStatus)>`.
   */
  using Func_void_AuthorizationRequestStatus = std::function<void(AuthorizationRequestStatus /* result */)>;
  /**
   * Wrapper class for a `std::function<void(AuthorizationRequestStatus / * result * /)>`, this can be used from Swift.
   */
  class Func_void_AuthorizationRequestStatus_Wrapper final {
  public:
    explicit Func_void_AuthorizationRequestStatus_Wrapper(std::function<void(AuthorizationRequestStatus /* result */)>&& func): _function(std::make_unique<std::function<void(AuthorizationRequestStatus /* result */)>>(std::move(func))) {}
    inline void call(int result) const noexcept {
      _function->operator()(static_cast<AuthorizationRequestStatus>(result));
    }
  private:
    std::unique_ptr<std::function<void(AuthorizationRequestStatus /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_AuthorizationRequestStatus create_Func_void_AuthorizationRequestStatus(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_AuthorizationRequestStatus_Wrapper wrap_Func_void_AuthorizationRequestStatus(Func_void_AuthorizationRequestStatus value) noexcept {
    return Func_void_AuthorizationRequestStatus_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::vector<SampleTypeIdentifierWriteable>
  /**
   * Specialized version of `std::vector<SampleTypeIdentifierWriteable>`.
   */
  using std__vector_SampleTypeIdentifierWriteable_ = std::vector<SampleTypeIdentifierWriteable>;
  inline std::vector<SampleTypeIdentifierWriteable> copy_std__vector_SampleTypeIdentifierWriteable_(const SampleTypeIdentifierWriteable* CONTIGUOUS_MEMORY NON_NULL data, size_t size) noexcept {
    return margelo::nitro::FastVectorCopy<SampleTypeIdentifierWriteable>(data, size);
  }
  inline const SampleTypeIdentifierWriteable* CONTIGUOUS_MEMORY NON_NULL get_data_std__vector_SampleTypeIdentifierWriteable_(const std::vector<SampleTypeIdentifierWriteable>& vector) noexcept {
    return vector.data();
  }
  
  // pragma MARK: std::vector<ObjectTypeIdentifier>
  /**
   * Specialized version of `std::vector<ObjectTypeIdentifier>`.
   */
  using std__vector_ObjectTypeIdentifier_ = std::vector<ObjectTypeIdentifier>;
  inline std::vector<ObjectTypeIdentifier> copy_std__vector_ObjectTypeIdentifier_(const ObjectTypeIdentifier* CONTIGUOUS_MEMORY NON_NULL data, size_t size) noexcept {
    return margelo::nitro::FastVectorCopy<ObjectTypeIdentifier>(data, size);
  }
  inline const ObjectTypeIdentifier* CONTIGUOUS_MEMORY NON_NULL get_data_std__vector_ObjectTypeIdentifier_(const std::vector<ObjectTypeIdentifier>& vector) noexcept {
    return vector.data();
  }
  
  // pragma MARK: std::unordered_map<std::string, bool>
  /**
   * Specialized version of `std::unordered_map<std::string, bool>`.
   */
  using std__unordered_map_std__string__bool_ = std::unordered_map<std::string, bool>;
  inline std::unordered_map<std::string, bool> create_std__unordered_map_std__string__bool_(size_t size) noexcept {
    std::unordered_map<std::string, bool> map;
    map.reserve(size);
    return map;
  }
  inline std::vector<std::string> get_std__unordered_map_std__string__bool__keys(const std__unordered_map_std__string__bool_& map) noexcept {
    std::vector<std::string> keys;
    keys.reserve(map.size());
    for (const auto& entry : map) {
      keys.push_back(entry.first);
    }
    return keys;
  }
  inline bool get_std__unordered_map_std__string__bool__value(const std__unordered_map_std__string__bool_& map, const std::string& key) noexcept {
    return map.find(key)->second;
  }
  inline void emplace_std__unordered_map_std__string__bool_(std__unordered_map_std__string__bool_& map, const std::string& key, const bool& value) noexcept {
    map.emplace(key, value);
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::unordered_map<std::string, bool>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::unordered_map<std::string, bool>>>`.
   */
  using std__shared_ptr_Promise_std__unordered_map_std__string__bool___ = std::shared_ptr<Promise<std::unordered_map<std::string, bool>>>;
  inline std::shared_ptr<Promise<std::unordered_map<std::string, bool>>> create_std__shared_ptr_Promise_std__unordered_map_std__string__bool___() noexcept {
    return Promise<std::unordered_map<std::string, bool>>::create();
  }
  inline PromiseHolder<std::unordered_map<std::string, bool>> wrap_std__shared_ptr_Promise_std__unordered_map_std__string__bool___(std::shared_ptr<Promise<std::unordered_map<std::string, bool>>> promise) noexcept {
    return PromiseHolder<std::unordered_map<std::string, bool>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::unordered_map<std::string, bool>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::unordered_map<std::string, bool>&)>`.
   */
  using Func_void_std__unordered_map_std__string__bool_ = std::function<void(const std::unordered_map<std::string, bool>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::unordered_map<std::string, bool>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__unordered_map_std__string__bool__Wrapper final {
  public:
    explicit Func_void_std__unordered_map_std__string__bool__Wrapper(std::function<void(const std::unordered_map<std::string, bool>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::unordered_map<std::string, bool>& /* result */)>>(std::move(func))) {}
    inline void call(std::unordered_map<std::string, bool> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::unordered_map<std::string, bool>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__unordered_map_std__string__bool_ create_Func_void_std__unordered_map_std__string__bool_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__unordered_map_std__string__bool__Wrapper wrap_Func_void_std__unordered_map_std__string__bool_(Func_void_std__unordered_map_std__string__bool_ value) noexcept {
    return Func_void_std__unordered_map_std__string__bool__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<HybridCoreModuleSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridCoreModuleSpec>`.
   */
  using std__shared_ptr_HybridCoreModuleSpec_ = std::shared_ptr<HybridCoreModuleSpec>;
  std::shared_ptr<HybridCoreModuleSpec> create_std__shared_ptr_HybridCoreModuleSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridCoreModuleSpec_(std__shared_ptr_HybridCoreModuleSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridCoreModuleSpec>
  using std__weak_ptr_HybridCoreModuleSpec_ = std::weak_ptr<HybridCoreModuleSpec>;
  inline std__weak_ptr_HybridCoreModuleSpec_ weakify_std__shared_ptr_HybridCoreModuleSpec_(const std::shared_ptr<HybridCoreModuleSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: Result<bool>
  using Result_bool_ = Result<bool>;
  inline Result_bool_ create_Result_bool_(bool value) noexcept {
    return Result<bool>::withValue(std::move(value));
  }
  inline Result_bool_ create_Result_bool_(const std::exception_ptr& error) noexcept {
    return Result<bool>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::vector<IdentifierWithUnit>>>>
  using Result_std__shared_ptr_Promise_std__vector_IdentifierWithUnit____ = Result<std::shared_ptr<Promise<std::vector<IdentifierWithUnit>>>>;
  inline Result_std__shared_ptr_Promise_std__vector_IdentifierWithUnit____ create_Result_std__shared_ptr_Promise_std__vector_IdentifierWithUnit____(const std::shared_ptr<Promise<std::vector<IdentifierWithUnit>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<IdentifierWithUnit>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__vector_IdentifierWithUnit____ create_Result_std__shared_ptr_Promise_std__vector_IdentifierWithUnit____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<IdentifierWithUnit>>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::vector<std::shared_ptr<HybridSourceProxySpec>>>>>
  using Result_std__shared_ptr_Promise_std__vector_std__shared_ptr_HybridSourceProxySpec_____ = Result<std::shared_ptr<Promise<std::vector<std::shared_ptr<HybridSourceProxySpec>>>>>;
  inline Result_std__shared_ptr_Promise_std__vector_std__shared_ptr_HybridSourceProxySpec_____ create_Result_std__shared_ptr_Promise_std__vector_std__shared_ptr_HybridSourceProxySpec_____(const std::shared_ptr<Promise<std::vector<std::shared_ptr<HybridSourceProxySpec>>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<std::shared_ptr<HybridSourceProxySpec>>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__vector_std__shared_ptr_HybridSourceProxySpec_____ create_Result_std__shared_ptr_Promise_std__vector_std__shared_ptr_HybridSourceProxySpec_____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<std::shared_ptr<HybridSourceProxySpec>>>>>::withError(error);
  }
  
  // pragma MARK: Result<std::string>
  using Result_std__string_ = Result<std::string>;
  inline Result_std__string_ create_Result_std__string_(const std::string& value) noexcept {
    return Result<std::string>::withValue(value);
  }
  inline Result_std__string_ create_Result_std__string_(const std::exception_ptr& error) noexcept {
    return Result<std::string>::withError(error);
  }
  
  // pragma MARK: Result<double>
  using Result_double_ = Result<double>;
  inline Result_double_ create_Result_double_(double value) noexcept {
    return Result<double>::withValue(std::move(value));
  }
  inline Result_double_ create_Result_double_(const std::exception_ptr& error) noexcept {
    return Result<double>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<double>>>
  using Result_std__shared_ptr_Promise_double___ = Result<std::shared_ptr<Promise<double>>>;
  inline Result_std__shared_ptr_Promise_double___ create_Result_std__shared_ptr_Promise_double___(const std::shared_ptr<Promise<double>>& value) noexcept {
    return Result<std::shared_ptr<Promise<double>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_double___ create_Result_std__shared_ptr_Promise_double___(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<double>>>::withError(error);
  }
  
  // pragma MARK: Result<AuthorizationStatus>
  using Result_AuthorizationStatus_ = Result<AuthorizationStatus>;
  inline Result_AuthorizationStatus_ create_Result_AuthorizationStatus_(AuthorizationStatus value) noexcept {
    return Result<AuthorizationStatus>::withValue(std::move(value));
  }
  inline Result_AuthorizationStatus_ create_Result_AuthorizationStatus_(const std::exception_ptr& error) noexcept {
    return Result<AuthorizationStatus>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<AuthorizationRequestStatus>>>
  using Result_std__shared_ptr_Promise_AuthorizationRequestStatus___ = Result<std::shared_ptr<Promise<AuthorizationRequestStatus>>>;
  inline Result_std__shared_ptr_Promise_AuthorizationRequestStatus___ create_Result_std__shared_ptr_Promise_AuthorizationRequestStatus___(const std::shared_ptr<Promise<AuthorizationRequestStatus>>& value) noexcept {
    return Result<std::shared_ptr<Promise<AuthorizationRequestStatus>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_AuthorizationRequestStatus___ create_Result_std__shared_ptr_Promise_AuthorizationRequestStatus___(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<AuthorizationRequestStatus>>>::withError(error);
  }
  
  // pragma MARK: Result<std::unordered_map<std::string, bool>>
  using Result_std__unordered_map_std__string__bool__ = Result<std::unordered_map<std::string, bool>>;
  inline Result_std__unordered_map_std__string__bool__ create_Result_std__unordered_map_std__string__bool__(const std::unordered_map<std::string, bool>& value) noexcept {
    return Result<std::unordered_map<std::string, bool>>::withValue(value);
  }
  inline Result_std__unordered_map_std__string__bool__ create_Result_std__unordered_map_std__string__bool__(const std::exception_ptr& error) noexcept {
    return Result<std::unordered_map<std::string, bool>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::unordered_map<std::string, bool>>>>
  using Result_std__shared_ptr_Promise_std__unordered_map_std__string__bool____ = Result<std::shared_ptr<Promise<std::unordered_map<std::string, bool>>>>;
  inline Result_std__shared_ptr_Promise_std__unordered_map_std__string__bool____ create_Result_std__shared_ptr_Promise_std__unordered_map_std__string__bool____(const std::shared_ptr<Promise<std::unordered_map<std::string, bool>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::unordered_map<std::string, bool>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__unordered_map_std__string__bool____ create_Result_std__shared_ptr_Promise_std__unordered_map_std__string__bool____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::unordered_map<std::string, bool>>>>::withError(error);
  }
  
  // pragma MARK: std::variant<CategorySampleForSaving, QuantitySampleForSaving>
  /**
   * Wrapper struct for `std::variant<CategorySampleForSaving, QuantitySampleForSaving>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_CategorySampleForSaving__QuantitySampleForSaving_ {
    std::variant<CategorySampleForSaving, QuantitySampleForSaving> variant;
    std__variant_CategorySampleForSaving__QuantitySampleForSaving_(std::variant<CategorySampleForSaving, QuantitySampleForSaving> variant): variant(variant) { }
    operator std::variant<CategorySampleForSaving, QuantitySampleForSaving>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline CategorySampleForSaving get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline QuantitySampleForSaving get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_CategorySampleForSaving__QuantitySampleForSaving_ create_std__variant_CategorySampleForSaving__QuantitySampleForSaving_(const CategorySampleForSaving& value) noexcept {
    return std__variant_CategorySampleForSaving__QuantitySampleForSaving_(value);
  }
  inline std__variant_CategorySampleForSaving__QuantitySampleForSaving_ create_std__variant_CategorySampleForSaving__QuantitySampleForSaving_(const QuantitySampleForSaving& value) noexcept {
    return std__variant_CategorySampleForSaving__QuantitySampleForSaving_(value);
  }
  
  // pragma MARK: std::vector<std::variant<CategorySampleForSaving, QuantitySampleForSaving>>
  /**
   * Specialized version of `std::vector<std::variant<CategorySampleForSaving, QuantitySampleForSaving>>`.
   */
  using std__vector_std__variant_CategorySampleForSaving__QuantitySampleForSaving__ = std::vector<std::variant<CategorySampleForSaving, QuantitySampleForSaving>>;
  inline std::vector<std::variant<CategorySampleForSaving, QuantitySampleForSaving>> create_std__vector_std__variant_CategorySampleForSaving__QuantitySampleForSaving__(size_t size) noexcept {
    std::vector<std::variant<CategorySampleForSaving, QuantitySampleForSaving>> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::variant<CategorySample, QuantitySample>
  /**
   * Wrapper struct for `std::variant<CategorySample, QuantitySample>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_CategorySample__QuantitySample_ {
    std::variant<CategorySample, QuantitySample> variant;
    std__variant_CategorySample__QuantitySample_(std::variant<CategorySample, QuantitySample> variant): variant(variant) { }
    operator std::variant<CategorySample, QuantitySample>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline CategorySample get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline QuantitySample get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_CategorySample__QuantitySample_ create_std__variant_CategorySample__QuantitySample_(const CategorySample& value) noexcept {
    return std__variant_CategorySample__QuantitySample_(value);
  }
  inline std__variant_CategorySample__QuantitySample_ create_std__variant_CategorySample__QuantitySample_(const QuantitySample& value) noexcept {
    return std__variant_CategorySample__QuantitySample_(value);
  }
  
  // pragma MARK: std::vector<std::variant<CategorySample, QuantitySample>>
  /**
   * Specialized version of `std::vector<std::variant<CategorySample, QuantitySample>>`.
   */
  using std__vector_std__variant_CategorySample__QuantitySample__ = std::vector<std::variant<CategorySample, QuantitySample>>;
  inline std::vector<std::variant<CategorySample, QuantitySample>> create_std__vector_std__variant_CategorySample__QuantitySample__(size_t size) noexcept {
    std::vector<std::variant<CategorySample, QuantitySample>> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::vector<CorrelationSample>
  /**
   * Specialized version of `std::vector<CorrelationSample>`.
   */
  using std__vector_CorrelationSample_ = std::vector<CorrelationSample>;
  inline std::vector<CorrelationSample> create_std__vector_CorrelationSample_(size_t size) noexcept {
    std::vector<CorrelationSample> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::vector<CorrelationSample>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::vector<CorrelationSample>>>`.
   */
  using std__shared_ptr_Promise_std__vector_CorrelationSample___ = std::shared_ptr<Promise<std::vector<CorrelationSample>>>;
  inline std::shared_ptr<Promise<std::vector<CorrelationSample>>> create_std__shared_ptr_Promise_std__vector_CorrelationSample___() noexcept {
    return Promise<std::vector<CorrelationSample>>::create();
  }
  inline PromiseHolder<std::vector<CorrelationSample>> wrap_std__shared_ptr_Promise_std__vector_CorrelationSample___(std::shared_ptr<Promise<std::vector<CorrelationSample>>> promise) noexcept {
    return PromiseHolder<std::vector<CorrelationSample>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::vector<CorrelationSample>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::vector<CorrelationSample>&)>`.
   */
  using Func_void_std__vector_CorrelationSample_ = std::function<void(const std::vector<CorrelationSample>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::vector<CorrelationSample>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__vector_CorrelationSample__Wrapper final {
  public:
    explicit Func_void_std__vector_CorrelationSample__Wrapper(std::function<void(const std::vector<CorrelationSample>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::vector<CorrelationSample>& /* result */)>>(std::move(func))) {}
    inline void call(std::vector<CorrelationSample> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::vector<CorrelationSample>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__vector_CorrelationSample_ create_Func_void_std__vector_CorrelationSample_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__vector_CorrelationSample__Wrapper wrap_Func_void_std__vector_CorrelationSample_(Func_void_std__vector_CorrelationSample_ value) noexcept {
    return Func_void_std__vector_CorrelationSample__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<HybridCorrelationTypeModuleSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridCorrelationTypeModuleSpec>`.
   */
  using std__shared_ptr_HybridCorrelationTypeModuleSpec_ = std::shared_ptr<HybridCorrelationTypeModuleSpec>;
  std::shared_ptr<HybridCorrelationTypeModuleSpec> create_std__shared_ptr_HybridCorrelationTypeModuleSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridCorrelationTypeModuleSpec_(std__shared_ptr_HybridCorrelationTypeModuleSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridCorrelationTypeModuleSpec>
  using std__weak_ptr_HybridCorrelationTypeModuleSpec_ = std::weak_ptr<HybridCorrelationTypeModuleSpec>;
  inline std__weak_ptr_HybridCorrelationTypeModuleSpec_ weakify_std__shared_ptr_HybridCorrelationTypeModuleSpec_(const std::shared_ptr<HybridCorrelationTypeModuleSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::vector<CorrelationSample>>>>
  using Result_std__shared_ptr_Promise_std__vector_CorrelationSample____ = Result<std::shared_ptr<Promise<std::vector<CorrelationSample>>>>;
  inline Result_std__shared_ptr_Promise_std__vector_CorrelationSample____ create_Result_std__shared_ptr_Promise_std__vector_CorrelationSample____(const std::shared_ptr<Promise<std::vector<CorrelationSample>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<CorrelationSample>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__vector_CorrelationSample____ create_Result_std__shared_ptr_Promise_std__vector_CorrelationSample____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<CorrelationSample>>>>::withError(error);
  }
  
  // pragma MARK: std::vector<ElectrocardiogramVoltage>
  /**
   * Specialized version of `std::vector<ElectrocardiogramVoltage>`.
   */
  using std__vector_ElectrocardiogramVoltage_ = std::vector<ElectrocardiogramVoltage>;
  inline std::vector<ElectrocardiogramVoltage> create_std__vector_ElectrocardiogramVoltage_(size_t size) noexcept {
    std::vector<ElectrocardiogramVoltage> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<ElectrocardiogramVoltage>>
  /**
   * Specialized version of `std::optional<std::vector<ElectrocardiogramVoltage>>`.
   */
  using std__optional_std__vector_ElectrocardiogramVoltage__ = std::optional<std::vector<ElectrocardiogramVoltage>>;
  inline std::optional<std::vector<ElectrocardiogramVoltage>> create_std__optional_std__vector_ElectrocardiogramVoltage__(const std::vector<ElectrocardiogramVoltage>& value) noexcept {
    return std::optional<std::vector<ElectrocardiogramVoltage>>(value);
  }
  inline bool has_value_std__optional_std__vector_ElectrocardiogramVoltage__(const std::optional<std::vector<ElectrocardiogramVoltage>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<ElectrocardiogramVoltage> get_std__optional_std__vector_ElectrocardiogramVoltage__(const std::optional<std::vector<ElectrocardiogramVoltage>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<ElectrocardiogramSample>
  /**
   * Specialized version of `std::vector<ElectrocardiogramSample>`.
   */
  using std__vector_ElectrocardiogramSample_ = std::vector<ElectrocardiogramSample>;
  inline std::vector<ElectrocardiogramSample> create_std__vector_ElectrocardiogramSample_(size_t size) noexcept {
    std::vector<ElectrocardiogramSample> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::vector<ElectrocardiogramSample>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::vector<ElectrocardiogramSample>>>`.
   */
  using std__shared_ptr_Promise_std__vector_ElectrocardiogramSample___ = std::shared_ptr<Promise<std::vector<ElectrocardiogramSample>>>;
  inline std::shared_ptr<Promise<std::vector<ElectrocardiogramSample>>> create_std__shared_ptr_Promise_std__vector_ElectrocardiogramSample___() noexcept {
    return Promise<std::vector<ElectrocardiogramSample>>::create();
  }
  inline PromiseHolder<std::vector<ElectrocardiogramSample>> wrap_std__shared_ptr_Promise_std__vector_ElectrocardiogramSample___(std::shared_ptr<Promise<std::vector<ElectrocardiogramSample>>> promise) noexcept {
    return PromiseHolder<std::vector<ElectrocardiogramSample>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::vector<ElectrocardiogramSample>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::vector<ElectrocardiogramSample>&)>`.
   */
  using Func_void_std__vector_ElectrocardiogramSample_ = std::function<void(const std::vector<ElectrocardiogramSample>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::vector<ElectrocardiogramSample>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__vector_ElectrocardiogramSample__Wrapper final {
  public:
    explicit Func_void_std__vector_ElectrocardiogramSample__Wrapper(std::function<void(const std::vector<ElectrocardiogramSample>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::vector<ElectrocardiogramSample>& /* result */)>>(std::move(func))) {}
    inline void call(std::vector<ElectrocardiogramSample> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::vector<ElectrocardiogramSample>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__vector_ElectrocardiogramSample_ create_Func_void_std__vector_ElectrocardiogramSample_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__vector_ElectrocardiogramSample__Wrapper wrap_Func_void_std__vector_ElectrocardiogramSample_(Func_void_std__vector_ElectrocardiogramSample_ value) noexcept {
    return Func_void_std__vector_ElectrocardiogramSample__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<ECGQueryOptionsWithSortOrder>
  /**
   * Specialized version of `std::optional<ECGQueryOptionsWithSortOrder>`.
   */
  using std__optional_ECGQueryOptionsWithSortOrder_ = std::optional<ECGQueryOptionsWithSortOrder>;
  inline std::optional<ECGQueryOptionsWithSortOrder> create_std__optional_ECGQueryOptionsWithSortOrder_(const ECGQueryOptionsWithSortOrder& value) noexcept {
    return std::optional<ECGQueryOptionsWithSortOrder>(value);
  }
  inline bool has_value_std__optional_ECGQueryOptionsWithSortOrder_(const std::optional<ECGQueryOptionsWithSortOrder>& optional) noexcept {
    return optional.has_value();
  }
  inline ECGQueryOptionsWithSortOrder get_std__optional_ECGQueryOptionsWithSortOrder_(const std::optional<ECGQueryOptionsWithSortOrder>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::shared_ptr<Promise<ElectrocardiogramSamplesWithAnchorResponse>>
  /**
   * Specialized version of `std::shared_ptr<Promise<ElectrocardiogramSamplesWithAnchorResponse>>`.
   */
  using std__shared_ptr_Promise_ElectrocardiogramSamplesWithAnchorResponse__ = std::shared_ptr<Promise<ElectrocardiogramSamplesWithAnchorResponse>>;
  inline std::shared_ptr<Promise<ElectrocardiogramSamplesWithAnchorResponse>> create_std__shared_ptr_Promise_ElectrocardiogramSamplesWithAnchorResponse__() noexcept {
    return Promise<ElectrocardiogramSamplesWithAnchorResponse>::create();
  }
  inline PromiseHolder<ElectrocardiogramSamplesWithAnchorResponse> wrap_std__shared_ptr_Promise_ElectrocardiogramSamplesWithAnchorResponse__(std::shared_ptr<Promise<ElectrocardiogramSamplesWithAnchorResponse>> promise) noexcept {
    return PromiseHolder<ElectrocardiogramSamplesWithAnchorResponse>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const ElectrocardiogramSamplesWithAnchorResponse& /* result */)>
  /**
   * Specialized version of `std::function<void(const ElectrocardiogramSamplesWithAnchorResponse&)>`.
   */
  using Func_void_ElectrocardiogramSamplesWithAnchorResponse = std::function<void(const ElectrocardiogramSamplesWithAnchorResponse& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const ElectrocardiogramSamplesWithAnchorResponse& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_ElectrocardiogramSamplesWithAnchorResponse_Wrapper final {
  public:
    explicit Func_void_ElectrocardiogramSamplesWithAnchorResponse_Wrapper(std::function<void(const ElectrocardiogramSamplesWithAnchorResponse& /* result */)>&& func): _function(std::make_unique<std::function<void(const ElectrocardiogramSamplesWithAnchorResponse& /* result */)>>(std::move(func))) {}
    inline void call(ElectrocardiogramSamplesWithAnchorResponse result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const ElectrocardiogramSamplesWithAnchorResponse& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_ElectrocardiogramSamplesWithAnchorResponse create_Func_void_ElectrocardiogramSamplesWithAnchorResponse(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_ElectrocardiogramSamplesWithAnchorResponse_Wrapper wrap_Func_void_ElectrocardiogramSamplesWithAnchorResponse(Func_void_ElectrocardiogramSamplesWithAnchorResponse value) noexcept {
    return Func_void_ElectrocardiogramSamplesWithAnchorResponse_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<HybridElectrocardiogramModuleSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridElectrocardiogramModuleSpec>`.
   */
  using std__shared_ptr_HybridElectrocardiogramModuleSpec_ = std::shared_ptr<HybridElectrocardiogramModuleSpec>;
  std::shared_ptr<HybridElectrocardiogramModuleSpec> create_std__shared_ptr_HybridElectrocardiogramModuleSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridElectrocardiogramModuleSpec_(std__shared_ptr_HybridElectrocardiogramModuleSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridElectrocardiogramModuleSpec>
  using std__weak_ptr_HybridElectrocardiogramModuleSpec_ = std::weak_ptr<HybridElectrocardiogramModuleSpec>;
  inline std__weak_ptr_HybridElectrocardiogramModuleSpec_ weakify_std__shared_ptr_HybridElectrocardiogramModuleSpec_(const std::shared_ptr<HybridElectrocardiogramModuleSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::vector<ElectrocardiogramSample>>>>
  using Result_std__shared_ptr_Promise_std__vector_ElectrocardiogramSample____ = Result<std::shared_ptr<Promise<std::vector<ElectrocardiogramSample>>>>;
  inline Result_std__shared_ptr_Promise_std__vector_ElectrocardiogramSample____ create_Result_std__shared_ptr_Promise_std__vector_ElectrocardiogramSample____(const std::shared_ptr<Promise<std::vector<ElectrocardiogramSample>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<ElectrocardiogramSample>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__vector_ElectrocardiogramSample____ create_Result_std__shared_ptr_Promise_std__vector_ElectrocardiogramSample____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<ElectrocardiogramSample>>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<ElectrocardiogramSamplesWithAnchorResponse>>>
  using Result_std__shared_ptr_Promise_ElectrocardiogramSamplesWithAnchorResponse___ = Result<std::shared_ptr<Promise<ElectrocardiogramSamplesWithAnchorResponse>>>;
  inline Result_std__shared_ptr_Promise_ElectrocardiogramSamplesWithAnchorResponse___ create_Result_std__shared_ptr_Promise_ElectrocardiogramSamplesWithAnchorResponse___(const std::shared_ptr<Promise<ElectrocardiogramSamplesWithAnchorResponse>>& value) noexcept {
    return Result<std::shared_ptr<Promise<ElectrocardiogramSamplesWithAnchorResponse>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_ElectrocardiogramSamplesWithAnchorResponse___ create_Result_std__shared_ptr_Promise_ElectrocardiogramSamplesWithAnchorResponse___(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<ElectrocardiogramSamplesWithAnchorResponse>>>::withError(error);
  }
  
  // pragma MARK: std::vector<Heartbeat>
  /**
   * Specialized version of `std::vector<Heartbeat>`.
   */
  using std__vector_Heartbeat_ = std::vector<Heartbeat>;
  inline std::vector<Heartbeat> create_std__vector_Heartbeat_(size_t size) noexcept {
    std::vector<Heartbeat> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::vector<HeartbeatSeriesSample>
  /**
   * Specialized version of `std::vector<HeartbeatSeriesSample>`.
   */
  using std__vector_HeartbeatSeriesSample_ = std::vector<HeartbeatSeriesSample>;
  inline std::vector<HeartbeatSeriesSample> create_std__vector_HeartbeatSeriesSample_(size_t size) noexcept {
    std::vector<HeartbeatSeriesSample> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::vector<HeartbeatSeriesSample>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::vector<HeartbeatSeriesSample>>>`.
   */
  using std__shared_ptr_Promise_std__vector_HeartbeatSeriesSample___ = std::shared_ptr<Promise<std::vector<HeartbeatSeriesSample>>>;
  inline std::shared_ptr<Promise<std::vector<HeartbeatSeriesSample>>> create_std__shared_ptr_Promise_std__vector_HeartbeatSeriesSample___() noexcept {
    return Promise<std::vector<HeartbeatSeriesSample>>::create();
  }
  inline PromiseHolder<std::vector<HeartbeatSeriesSample>> wrap_std__shared_ptr_Promise_std__vector_HeartbeatSeriesSample___(std::shared_ptr<Promise<std::vector<HeartbeatSeriesSample>>> promise) noexcept {
    return PromiseHolder<std::vector<HeartbeatSeriesSample>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::vector<HeartbeatSeriesSample>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::vector<HeartbeatSeriesSample>&)>`.
   */
  using Func_void_std__vector_HeartbeatSeriesSample_ = std::function<void(const std::vector<HeartbeatSeriesSample>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::vector<HeartbeatSeriesSample>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__vector_HeartbeatSeriesSample__Wrapper final {
  public:
    explicit Func_void_std__vector_HeartbeatSeriesSample__Wrapper(std::function<void(const std::vector<HeartbeatSeriesSample>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::vector<HeartbeatSeriesSample>& /* result */)>>(std::move(func))) {}
    inline void call(std::vector<HeartbeatSeriesSample> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::vector<HeartbeatSeriesSample>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__vector_HeartbeatSeriesSample_ create_Func_void_std__vector_HeartbeatSeriesSample_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__vector_HeartbeatSeriesSample__Wrapper wrap_Func_void_std__vector_HeartbeatSeriesSample_(Func_void_std__vector_HeartbeatSeriesSample_ value) noexcept {
    return Func_void_std__vector_HeartbeatSeriesSample__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<Promise<HeartbeatSeriesSamplesWithAnchorResponse>>
  /**
   * Specialized version of `std::shared_ptr<Promise<HeartbeatSeriesSamplesWithAnchorResponse>>`.
   */
  using std__shared_ptr_Promise_HeartbeatSeriesSamplesWithAnchorResponse__ = std::shared_ptr<Promise<HeartbeatSeriesSamplesWithAnchorResponse>>;
  inline std::shared_ptr<Promise<HeartbeatSeriesSamplesWithAnchorResponse>> create_std__shared_ptr_Promise_HeartbeatSeriesSamplesWithAnchorResponse__() noexcept {
    return Promise<HeartbeatSeriesSamplesWithAnchorResponse>::create();
  }
  inline PromiseHolder<HeartbeatSeriesSamplesWithAnchorResponse> wrap_std__shared_ptr_Promise_HeartbeatSeriesSamplesWithAnchorResponse__(std::shared_ptr<Promise<HeartbeatSeriesSamplesWithAnchorResponse>> promise) noexcept {
    return PromiseHolder<HeartbeatSeriesSamplesWithAnchorResponse>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const HeartbeatSeriesSamplesWithAnchorResponse& /* result */)>
  /**
   * Specialized version of `std::function<void(const HeartbeatSeriesSamplesWithAnchorResponse&)>`.
   */
  using Func_void_HeartbeatSeriesSamplesWithAnchorResponse = std::function<void(const HeartbeatSeriesSamplesWithAnchorResponse& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const HeartbeatSeriesSamplesWithAnchorResponse& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_HeartbeatSeriesSamplesWithAnchorResponse_Wrapper final {
  public:
    explicit Func_void_HeartbeatSeriesSamplesWithAnchorResponse_Wrapper(std::function<void(const HeartbeatSeriesSamplesWithAnchorResponse& /* result */)>&& func): _function(std::make_unique<std::function<void(const HeartbeatSeriesSamplesWithAnchorResponse& /* result */)>>(std::move(func))) {}
    inline void call(HeartbeatSeriesSamplesWithAnchorResponse result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const HeartbeatSeriesSamplesWithAnchorResponse& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_HeartbeatSeriesSamplesWithAnchorResponse create_Func_void_HeartbeatSeriesSamplesWithAnchorResponse(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_HeartbeatSeriesSamplesWithAnchorResponse_Wrapper wrap_Func_void_HeartbeatSeriesSamplesWithAnchorResponse(Func_void_HeartbeatSeriesSamplesWithAnchorResponse value) noexcept {
    return Func_void_HeartbeatSeriesSamplesWithAnchorResponse_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<HybridHeartbeatSeriesModuleSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridHeartbeatSeriesModuleSpec>`.
   */
  using std__shared_ptr_HybridHeartbeatSeriesModuleSpec_ = std::shared_ptr<HybridHeartbeatSeriesModuleSpec>;
  std::shared_ptr<HybridHeartbeatSeriesModuleSpec> create_std__shared_ptr_HybridHeartbeatSeriesModuleSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridHeartbeatSeriesModuleSpec_(std__shared_ptr_HybridHeartbeatSeriesModuleSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridHeartbeatSeriesModuleSpec>
  using std__weak_ptr_HybridHeartbeatSeriesModuleSpec_ = std::weak_ptr<HybridHeartbeatSeriesModuleSpec>;
  inline std__weak_ptr_HybridHeartbeatSeriesModuleSpec_ weakify_std__shared_ptr_HybridHeartbeatSeriesModuleSpec_(const std::shared_ptr<HybridHeartbeatSeriesModuleSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::vector<HeartbeatSeriesSample>>>>
  using Result_std__shared_ptr_Promise_std__vector_HeartbeatSeriesSample____ = Result<std::shared_ptr<Promise<std::vector<HeartbeatSeriesSample>>>>;
  inline Result_std__shared_ptr_Promise_std__vector_HeartbeatSeriesSample____ create_Result_std__shared_ptr_Promise_std__vector_HeartbeatSeriesSample____(const std::shared_ptr<Promise<std::vector<HeartbeatSeriesSample>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<HeartbeatSeriesSample>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__vector_HeartbeatSeriesSample____ create_Result_std__shared_ptr_Promise_std__vector_HeartbeatSeriesSample____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<HeartbeatSeriesSample>>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<HeartbeatSeriesSamplesWithAnchorResponse>>>
  using Result_std__shared_ptr_Promise_HeartbeatSeriesSamplesWithAnchorResponse___ = Result<std::shared_ptr<Promise<HeartbeatSeriesSamplesWithAnchorResponse>>>;
  inline Result_std__shared_ptr_Promise_HeartbeatSeriesSamplesWithAnchorResponse___ create_Result_std__shared_ptr_Promise_HeartbeatSeriesSamplesWithAnchorResponse___(const std::shared_ptr<Promise<HeartbeatSeriesSamplesWithAnchorResponse>>& value) noexcept {
    return Result<std::shared_ptr<Promise<HeartbeatSeriesSamplesWithAnchorResponse>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_HeartbeatSeriesSamplesWithAnchorResponse___ create_Result_std__shared_ptr_Promise_HeartbeatSeriesSamplesWithAnchorResponse___(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<HeartbeatSeriesSamplesWithAnchorResponse>>>::withError(error);
  }
  
  // pragma MARK: std::vector<QuantitySample>
  /**
   * Specialized version of `std::vector<QuantitySample>`.
   */
  using std__vector_QuantitySample_ = std::vector<QuantitySample>;
  inline std::vector<QuantitySample> create_std__vector_QuantitySample_(size_t size) noexcept {
    std::vector<QuantitySample> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::vector<QuantitySample>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::vector<QuantitySample>>>`.
   */
  using std__shared_ptr_Promise_std__vector_QuantitySample___ = std::shared_ptr<Promise<std::vector<QuantitySample>>>;
  inline std::shared_ptr<Promise<std::vector<QuantitySample>>> create_std__shared_ptr_Promise_std__vector_QuantitySample___() noexcept {
    return Promise<std::vector<QuantitySample>>::create();
  }
  inline PromiseHolder<std::vector<QuantitySample>> wrap_std__shared_ptr_Promise_std__vector_QuantitySample___(std::shared_ptr<Promise<std::vector<QuantitySample>>> promise) noexcept {
    return PromiseHolder<std::vector<QuantitySample>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::vector<QuantitySample>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::vector<QuantitySample>&)>`.
   */
  using Func_void_std__vector_QuantitySample_ = std::function<void(const std::vector<QuantitySample>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::vector<QuantitySample>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__vector_QuantitySample__Wrapper final {
  public:
    explicit Func_void_std__vector_QuantitySample__Wrapper(std::function<void(const std::vector<QuantitySample>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::vector<QuantitySample>& /* result */)>>(std::move(func))) {}
    inline void call(std::vector<QuantitySample> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::vector<QuantitySample>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__vector_QuantitySample_ create_Func_void_std__vector_QuantitySample_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__vector_QuantitySample__Wrapper wrap_Func_void_std__vector_QuantitySample_(Func_void_std__vector_QuantitySample_ value) noexcept {
    return Func_void_std__vector_QuantitySample__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<QueryOptionsWithSortOrderAndUnit>
  /**
   * Specialized version of `std::optional<QueryOptionsWithSortOrderAndUnit>`.
   */
  using std__optional_QueryOptionsWithSortOrderAndUnit_ = std::optional<QueryOptionsWithSortOrderAndUnit>;
  inline std::optional<QueryOptionsWithSortOrderAndUnit> create_std__optional_QueryOptionsWithSortOrderAndUnit_(const QueryOptionsWithSortOrderAndUnit& value) noexcept {
    return std::optional<QueryOptionsWithSortOrderAndUnit>(value);
  }
  inline bool has_value_std__optional_QueryOptionsWithSortOrderAndUnit_(const std::optional<QueryOptionsWithSortOrderAndUnit>& optional) noexcept {
    return optional.has_value();
  }
  inline QueryOptionsWithSortOrderAndUnit get_std__optional_QueryOptionsWithSortOrderAndUnit_(const std::optional<QueryOptionsWithSortOrderAndUnit>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<Quantity>
  /**
   * Specialized version of `std::optional<Quantity>`.
   */
  using std__optional_Quantity_ = std::optional<Quantity>;
  inline std::optional<Quantity> create_std__optional_Quantity_(const Quantity& value) noexcept {
    return std::optional<Quantity>(value);
  }
  inline bool has_value_std__optional_Quantity_(const std::optional<Quantity>& optional) noexcept {
    return optional.has_value();
  }
  inline Quantity get_std__optional_Quantity_(const std::optional<Quantity>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<QuantityDateInterval>
  /**
   * Specialized version of `std::optional<QuantityDateInterval>`.
   */
  using std__optional_QuantityDateInterval_ = std::optional<QuantityDateInterval>;
  inline std::optional<QuantityDateInterval> create_std__optional_QuantityDateInterval_(const QuantityDateInterval& value) noexcept {
    return std::optional<QuantityDateInterval>(value);
  }
  inline bool has_value_std__optional_QuantityDateInterval_(const std::optional<QuantityDateInterval>& optional) noexcept {
    return optional.has_value();
  }
  inline QuantityDateInterval get_std__optional_QuantityDateInterval_(const std::optional<QuantityDateInterval>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::shared_ptr<Promise<QueryStatisticsResponse>>
  /**
   * Specialized version of `std::shared_ptr<Promise<QueryStatisticsResponse>>`.
   */
  using std__shared_ptr_Promise_QueryStatisticsResponse__ = std::shared_ptr<Promise<QueryStatisticsResponse>>;
  inline std::shared_ptr<Promise<QueryStatisticsResponse>> create_std__shared_ptr_Promise_QueryStatisticsResponse__() noexcept {
    return Promise<QueryStatisticsResponse>::create();
  }
  inline PromiseHolder<QueryStatisticsResponse> wrap_std__shared_ptr_Promise_QueryStatisticsResponse__(std::shared_ptr<Promise<QueryStatisticsResponse>> promise) noexcept {
    return PromiseHolder<QueryStatisticsResponse>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const QueryStatisticsResponse& /* result */)>
  /**
   * Specialized version of `std::function<void(const QueryStatisticsResponse&)>`.
   */
  using Func_void_QueryStatisticsResponse = std::function<void(const QueryStatisticsResponse& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const QueryStatisticsResponse& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_QueryStatisticsResponse_Wrapper final {
  public:
    explicit Func_void_QueryStatisticsResponse_Wrapper(std::function<void(const QueryStatisticsResponse& /* result */)>&& func): _function(std::make_unique<std::function<void(const QueryStatisticsResponse& /* result */)>>(std::move(func))) {}
    inline void call(QueryStatisticsResponse result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const QueryStatisticsResponse& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_QueryStatisticsResponse create_Func_void_QueryStatisticsResponse(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_QueryStatisticsResponse_Wrapper wrap_Func_void_QueryStatisticsResponse(Func_void_QueryStatisticsResponse value) noexcept {
    return Func_void_QueryStatisticsResponse_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::vector<StatisticsOptions>
  /**
   * Specialized version of `std::vector<StatisticsOptions>`.
   */
  using std__vector_StatisticsOptions_ = std::vector<StatisticsOptions>;
  inline std::vector<StatisticsOptions> copy_std__vector_StatisticsOptions_(const StatisticsOptions* CONTIGUOUS_MEMORY NON_NULL data, size_t size) noexcept {
    return margelo::nitro::FastVectorCopy<StatisticsOptions>(data, size);
  }
  inline const StatisticsOptions* CONTIGUOUS_MEMORY NON_NULL get_data_std__vector_StatisticsOptions_(const std::vector<StatisticsOptions>& vector) noexcept {
    return vector.data();
  }
  
  // pragma MARK: std::optional<StatisticsQueryOptions>
  /**
   * Specialized version of `std::optional<StatisticsQueryOptions>`.
   */
  using std__optional_StatisticsQueryOptions_ = std::optional<StatisticsQueryOptions>;
  inline std::optional<StatisticsQueryOptions> create_std__optional_StatisticsQueryOptions_(const StatisticsQueryOptions& value) noexcept {
    return std::optional<StatisticsQueryOptions>(value);
  }
  inline bool has_value_std__optional_StatisticsQueryOptions_(const std::optional<StatisticsQueryOptions>& optional) noexcept {
    return optional.has_value();
  }
  inline StatisticsQueryOptions get_std__optional_StatisticsQueryOptions_(const std::optional<StatisticsQueryOptions>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<QueryStatisticsResponse>
  /**
   * Specialized version of `std::vector<QueryStatisticsResponse>`.
   */
  using std__vector_QueryStatisticsResponse_ = std::vector<QueryStatisticsResponse>;
  inline std::vector<QueryStatisticsResponse> create_std__vector_QueryStatisticsResponse_(size_t size) noexcept {
    std::vector<QueryStatisticsResponse> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::vector<QueryStatisticsResponse>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::vector<QueryStatisticsResponse>>>`.
   */
  using std__shared_ptr_Promise_std__vector_QueryStatisticsResponse___ = std::shared_ptr<Promise<std::vector<QueryStatisticsResponse>>>;
  inline std::shared_ptr<Promise<std::vector<QueryStatisticsResponse>>> create_std__shared_ptr_Promise_std__vector_QueryStatisticsResponse___() noexcept {
    return Promise<std::vector<QueryStatisticsResponse>>::create();
  }
  inline PromiseHolder<std::vector<QueryStatisticsResponse>> wrap_std__shared_ptr_Promise_std__vector_QueryStatisticsResponse___(std::shared_ptr<Promise<std::vector<QueryStatisticsResponse>>> promise) noexcept {
    return PromiseHolder<std::vector<QueryStatisticsResponse>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::vector<QueryStatisticsResponse>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::vector<QueryStatisticsResponse>&)>`.
   */
  using Func_void_std__vector_QueryStatisticsResponse_ = std::function<void(const std::vector<QueryStatisticsResponse>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::vector<QueryStatisticsResponse>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__vector_QueryStatisticsResponse__Wrapper final {
  public:
    explicit Func_void_std__vector_QueryStatisticsResponse__Wrapper(std::function<void(const std::vector<QueryStatisticsResponse>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::vector<QueryStatisticsResponse>& /* result */)>>(std::move(func))) {}
    inline void call(std::vector<QueryStatisticsResponse> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::vector<QueryStatisticsResponse>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__vector_QueryStatisticsResponse_ create_Func_void_std__vector_QueryStatisticsResponse_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__vector_QueryStatisticsResponse__Wrapper wrap_Func_void_std__vector_QueryStatisticsResponse_(Func_void_std__vector_QueryStatisticsResponse_ value) noexcept {
    return Func_void_std__vector_QueryStatisticsResponse__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<Promise<QuantitySamplesWithAnchorResponse>>
  /**
   * Specialized version of `std::shared_ptr<Promise<QuantitySamplesWithAnchorResponse>>`.
   */
  using std__shared_ptr_Promise_QuantitySamplesWithAnchorResponse__ = std::shared_ptr<Promise<QuantitySamplesWithAnchorResponse>>;
  inline std::shared_ptr<Promise<QuantitySamplesWithAnchorResponse>> create_std__shared_ptr_Promise_QuantitySamplesWithAnchorResponse__() noexcept {
    return Promise<QuantitySamplesWithAnchorResponse>::create();
  }
  inline PromiseHolder<QuantitySamplesWithAnchorResponse> wrap_std__shared_ptr_Promise_QuantitySamplesWithAnchorResponse__(std::shared_ptr<Promise<QuantitySamplesWithAnchorResponse>> promise) noexcept {
    return PromiseHolder<QuantitySamplesWithAnchorResponse>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const QuantitySamplesWithAnchorResponse& /* result */)>
  /**
   * Specialized version of `std::function<void(const QuantitySamplesWithAnchorResponse&)>`.
   */
  using Func_void_QuantitySamplesWithAnchorResponse = std::function<void(const QuantitySamplesWithAnchorResponse& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const QuantitySamplesWithAnchorResponse& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_QuantitySamplesWithAnchorResponse_Wrapper final {
  public:
    explicit Func_void_QuantitySamplesWithAnchorResponse_Wrapper(std::function<void(const QuantitySamplesWithAnchorResponse& /* result */)>&& func): _function(std::make_unique<std::function<void(const QuantitySamplesWithAnchorResponse& /* result */)>>(std::move(func))) {}
    inline void call(QuantitySamplesWithAnchorResponse result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const QuantitySamplesWithAnchorResponse& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_QuantitySamplesWithAnchorResponse create_Func_void_QuantitySamplesWithAnchorResponse(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_QuantitySamplesWithAnchorResponse_Wrapper wrap_Func_void_QuantitySamplesWithAnchorResponse(Func_void_QuantitySamplesWithAnchorResponse value) noexcept {
    return Func_void_QuantitySamplesWithAnchorResponse_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<HybridQuantityTypeModuleSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridQuantityTypeModuleSpec>`.
   */
  using std__shared_ptr_HybridQuantityTypeModuleSpec_ = std::shared_ptr<HybridQuantityTypeModuleSpec>;
  std::shared_ptr<HybridQuantityTypeModuleSpec> create_std__shared_ptr_HybridQuantityTypeModuleSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridQuantityTypeModuleSpec_(std__shared_ptr_HybridQuantityTypeModuleSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridQuantityTypeModuleSpec>
  using std__weak_ptr_HybridQuantityTypeModuleSpec_ = std::weak_ptr<HybridQuantityTypeModuleSpec>;
  inline std__weak_ptr_HybridQuantityTypeModuleSpec_ weakify_std__shared_ptr_HybridQuantityTypeModuleSpec_(const std::shared_ptr<HybridQuantityTypeModuleSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::vector<QuantitySample>>>>
  using Result_std__shared_ptr_Promise_std__vector_QuantitySample____ = Result<std::shared_ptr<Promise<std::vector<QuantitySample>>>>;
  inline Result_std__shared_ptr_Promise_std__vector_QuantitySample____ create_Result_std__shared_ptr_Promise_std__vector_QuantitySample____(const std::shared_ptr<Promise<std::vector<QuantitySample>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<QuantitySample>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__vector_QuantitySample____ create_Result_std__shared_ptr_Promise_std__vector_QuantitySample____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<QuantitySample>>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<QueryStatisticsResponse>>>
  using Result_std__shared_ptr_Promise_QueryStatisticsResponse___ = Result<std::shared_ptr<Promise<QueryStatisticsResponse>>>;
  inline Result_std__shared_ptr_Promise_QueryStatisticsResponse___ create_Result_std__shared_ptr_Promise_QueryStatisticsResponse___(const std::shared_ptr<Promise<QueryStatisticsResponse>>& value) noexcept {
    return Result<std::shared_ptr<Promise<QueryStatisticsResponse>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_QueryStatisticsResponse___ create_Result_std__shared_ptr_Promise_QueryStatisticsResponse___(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<QueryStatisticsResponse>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::vector<QueryStatisticsResponse>>>>
  using Result_std__shared_ptr_Promise_std__vector_QueryStatisticsResponse____ = Result<std::shared_ptr<Promise<std::vector<QueryStatisticsResponse>>>>;
  inline Result_std__shared_ptr_Promise_std__vector_QueryStatisticsResponse____ create_Result_std__shared_ptr_Promise_std__vector_QueryStatisticsResponse____(const std::shared_ptr<Promise<std::vector<QueryStatisticsResponse>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<QueryStatisticsResponse>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__vector_QueryStatisticsResponse____ create_Result_std__shared_ptr_Promise_std__vector_QueryStatisticsResponse____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<QueryStatisticsResponse>>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<QuantitySamplesWithAnchorResponse>>>
  using Result_std__shared_ptr_Promise_QuantitySamplesWithAnchorResponse___ = Result<std::shared_ptr<Promise<QuantitySamplesWithAnchorResponse>>>;
  inline Result_std__shared_ptr_Promise_QuantitySamplesWithAnchorResponse___ create_Result_std__shared_ptr_Promise_QuantitySamplesWithAnchorResponse___(const std::shared_ptr<Promise<QuantitySamplesWithAnchorResponse>>& value) noexcept {
    return Result<std::shared_ptr<Promise<QuantitySamplesWithAnchorResponse>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_QuantitySamplesWithAnchorResponse___ create_Result_std__shared_ptr_Promise_QuantitySamplesWithAnchorResponse___(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<QuantitySamplesWithAnchorResponse>>>::withError(error);
  }
  
  // pragma MARK: Result<Source>
  using Result_Source_ = Result<Source>;
  inline Result_Source_ create_Result_Source_(const Source& value) noexcept {
    return Result<Source>::withValue(value);
  }
  inline Result_Source_ create_Result_Source_(const std::exception_ptr& error) noexcept {
    return Result<Source>::withError(error);
  }
  
  // pragma MARK: std::vector<StateOfMindAssociation>
  /**
   * Specialized version of `std::vector<StateOfMindAssociation>`.
   */
  using std__vector_StateOfMindAssociation_ = std::vector<StateOfMindAssociation>;
  inline std::vector<StateOfMindAssociation> copy_std__vector_StateOfMindAssociation_(const StateOfMindAssociation* CONTIGUOUS_MEMORY NON_NULL data, size_t size) noexcept {
    return margelo::nitro::FastVectorCopy<StateOfMindAssociation>(data, size);
  }
  inline const StateOfMindAssociation* CONTIGUOUS_MEMORY NON_NULL get_data_std__vector_StateOfMindAssociation_(const std::vector<StateOfMindAssociation>& vector) noexcept {
    return vector.data();
  }
  
  // pragma MARK: std::vector<StateOfMindLabel>
  /**
   * Specialized version of `std::vector<StateOfMindLabel>`.
   */
  using std__vector_StateOfMindLabel_ = std::vector<StateOfMindLabel>;
  inline std::vector<StateOfMindLabel> copy_std__vector_StateOfMindLabel_(const StateOfMindLabel* CONTIGUOUS_MEMORY NON_NULL data, size_t size) noexcept {
    return margelo::nitro::FastVectorCopy<StateOfMindLabel>(data, size);
  }
  inline const StateOfMindLabel* CONTIGUOUS_MEMORY NON_NULL get_data_std__vector_StateOfMindLabel_(const std::vector<StateOfMindLabel>& vector) noexcept {
    return vector.data();
  }
  
  // pragma MARK: std::vector<StateOfMindSample>
  /**
   * Specialized version of `std::vector<StateOfMindSample>`.
   */
  using std__vector_StateOfMindSample_ = std::vector<StateOfMindSample>;
  inline std::vector<StateOfMindSample> create_std__vector_StateOfMindSample_(size_t size) noexcept {
    std::vector<StateOfMindSample> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::vector<StateOfMindSample>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::vector<StateOfMindSample>>>`.
   */
  using std__shared_ptr_Promise_std__vector_StateOfMindSample___ = std::shared_ptr<Promise<std::vector<StateOfMindSample>>>;
  inline std::shared_ptr<Promise<std::vector<StateOfMindSample>>> create_std__shared_ptr_Promise_std__vector_StateOfMindSample___() noexcept {
    return Promise<std::vector<StateOfMindSample>>::create();
  }
  inline PromiseHolder<std::vector<StateOfMindSample>> wrap_std__shared_ptr_Promise_std__vector_StateOfMindSample___(std::shared_ptr<Promise<std::vector<StateOfMindSample>>> promise) noexcept {
    return PromiseHolder<std::vector<StateOfMindSample>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::vector<StateOfMindSample>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::vector<StateOfMindSample>&)>`.
   */
  using Func_void_std__vector_StateOfMindSample_ = std::function<void(const std::vector<StateOfMindSample>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::vector<StateOfMindSample>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__vector_StateOfMindSample__Wrapper final {
  public:
    explicit Func_void_std__vector_StateOfMindSample__Wrapper(std::function<void(const std::vector<StateOfMindSample>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::vector<StateOfMindSample>& /* result */)>>(std::move(func))) {}
    inline void call(std::vector<StateOfMindSample> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::vector<StateOfMindSample>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__vector_StateOfMindSample_ create_Func_void_std__vector_StateOfMindSample_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__vector_StateOfMindSample__Wrapper wrap_Func_void_std__vector_StateOfMindSample_(Func_void_std__vector_StateOfMindSample_ value) noexcept {
    return Func_void_std__vector_StateOfMindSample__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<HybridStateOfMindModuleSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridStateOfMindModuleSpec>`.
   */
  using std__shared_ptr_HybridStateOfMindModuleSpec_ = std::shared_ptr<HybridStateOfMindModuleSpec>;
  std::shared_ptr<HybridStateOfMindModuleSpec> create_std__shared_ptr_HybridStateOfMindModuleSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridStateOfMindModuleSpec_(std__shared_ptr_HybridStateOfMindModuleSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridStateOfMindModuleSpec>
  using std__weak_ptr_HybridStateOfMindModuleSpec_ = std::weak_ptr<HybridStateOfMindModuleSpec>;
  inline std__weak_ptr_HybridStateOfMindModuleSpec_ weakify_std__shared_ptr_HybridStateOfMindModuleSpec_(const std::shared_ptr<HybridStateOfMindModuleSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::vector<StateOfMindSample>>>>
  using Result_std__shared_ptr_Promise_std__vector_StateOfMindSample____ = Result<std::shared_ptr<Promise<std::vector<StateOfMindSample>>>>;
  inline Result_std__shared_ptr_Promise_std__vector_StateOfMindSample____ create_Result_std__shared_ptr_Promise_std__vector_StateOfMindSample____(const std::shared_ptr<Promise<std::vector<StateOfMindSample>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<StateOfMindSample>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__vector_StateOfMindSample____ create_Result_std__shared_ptr_Promise_std__vector_StateOfMindSample____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<StateOfMindSample>>>>::withError(error);
  }
  
  // pragma MARK: std::vector<WorkoutEvent>
  /**
   * Specialized version of `std::vector<WorkoutEvent>`.
   */
  using std__vector_WorkoutEvent_ = std::vector<WorkoutEvent>;
  inline std::vector<WorkoutEvent> create_std__vector_WorkoutEvent_(size_t size) noexcept {
    std::vector<WorkoutEvent> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<WorkoutEvent>>
  /**
   * Specialized version of `std::optional<std::vector<WorkoutEvent>>`.
   */
  using std__optional_std__vector_WorkoutEvent__ = std::optional<std::vector<WorkoutEvent>>;
  inline std::optional<std::vector<WorkoutEvent>> create_std__optional_std__vector_WorkoutEvent__(const std::vector<WorkoutEvent>& value) noexcept {
    return std::optional<std::vector<WorkoutEvent>>(value);
  }
  inline bool has_value_std__optional_std__vector_WorkoutEvent__(const std::optional<std::vector<WorkoutEvent>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<WorkoutEvent> get_std__optional_std__vector_WorkoutEvent__(const std::optional<std::vector<WorkoutEvent>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<WorkoutActivity>
  /**
   * Specialized version of `std::vector<WorkoutActivity>`.
   */
  using std__vector_WorkoutActivity_ = std::vector<WorkoutActivity>;
  inline std::vector<WorkoutActivity> create_std__vector_WorkoutActivity_(size_t size) noexcept {
    std::vector<WorkoutActivity> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<WorkoutActivity>>
  /**
   * Specialized version of `std::optional<std::vector<WorkoutActivity>>`.
   */
  using std__optional_std__vector_WorkoutActivity__ = std::optional<std::vector<WorkoutActivity>>;
  inline std::optional<std::vector<WorkoutActivity>> create_std__optional_std__vector_WorkoutActivity__(const std::vector<WorkoutActivity>& value) noexcept {
    return std::optional<std::vector<WorkoutActivity>>(value);
  }
  inline bool has_value_std__optional_std__vector_WorkoutActivity__(const std::optional<std::vector<WorkoutActivity>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<WorkoutActivity> get_std__optional_std__vector_WorkoutActivity__(const std::optional<std::vector<WorkoutActivity>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<LocationForSaving>
  /**
   * Specialized version of `std::vector<LocationForSaving>`.
   */
  using std__vector_LocationForSaving_ = std::vector<LocationForSaving>;
  inline std::vector<LocationForSaving> create_std__vector_LocationForSaving_(size_t size) noexcept {
    std::vector<LocationForSaving> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<WorkoutPlan>
  /**
   * Specialized version of `std::optional<WorkoutPlan>`.
   */
  using std__optional_WorkoutPlan_ = std::optional<WorkoutPlan>;
  inline std::optional<WorkoutPlan> create_std__optional_WorkoutPlan_(const WorkoutPlan& value) noexcept {
    return std::optional<WorkoutPlan>(value);
  }
  inline bool has_value_std__optional_WorkoutPlan_(const std::optional<WorkoutPlan>& optional) noexcept {
    return optional.has_value();
  }
  inline WorkoutPlan get_std__optional_WorkoutPlan_(const std::optional<WorkoutPlan>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::optional<WorkoutPlan>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::optional<WorkoutPlan>>>`.
   */
  using std__shared_ptr_Promise_std__optional_WorkoutPlan___ = std::shared_ptr<Promise<std::optional<WorkoutPlan>>>;
  inline std::shared_ptr<Promise<std::optional<WorkoutPlan>>> create_std__shared_ptr_Promise_std__optional_WorkoutPlan___() noexcept {
    return Promise<std::optional<WorkoutPlan>>::create();
  }
  inline PromiseHolder<std::optional<WorkoutPlan>> wrap_std__shared_ptr_Promise_std__optional_WorkoutPlan___(std::shared_ptr<Promise<std::optional<WorkoutPlan>>> promise) noexcept {
    return PromiseHolder<std::optional<WorkoutPlan>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::optional<WorkoutPlan>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::optional<WorkoutPlan>&)>`.
   */
  using Func_void_std__optional_WorkoutPlan_ = std::function<void(const std::optional<WorkoutPlan>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::optional<WorkoutPlan>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__optional_WorkoutPlan__Wrapper final {
  public:
    explicit Func_void_std__optional_WorkoutPlan__Wrapper(std::function<void(const std::optional<WorkoutPlan>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::optional<WorkoutPlan>& /* result */)>>(std::move(func))) {}
    inline void call(std::optional<WorkoutPlan> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::optional<WorkoutPlan>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__optional_WorkoutPlan_ create_Func_void_std__optional_WorkoutPlan_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__optional_WorkoutPlan__Wrapper wrap_Func_void_std__optional_WorkoutPlan_(Func_void_std__optional_WorkoutPlan_ value) noexcept {
    return Func_void_std__optional_WorkoutPlan__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::vector<WorkoutRouteLocation>
  /**
   * Specialized version of `std::vector<WorkoutRouteLocation>`.
   */
  using std__vector_WorkoutRouteLocation_ = std::vector<WorkoutRouteLocation>;
  inline std::vector<WorkoutRouteLocation> create_std__vector_WorkoutRouteLocation_(size_t size) noexcept {
    std::vector<WorkoutRouteLocation> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::vector<WorkoutRoute>
  /**
   * Specialized version of `std::vector<WorkoutRoute>`.
   */
  using std__vector_WorkoutRoute_ = std::vector<WorkoutRoute>;
  inline std::vector<WorkoutRoute> create_std__vector_WorkoutRoute_(size_t size) noexcept {
    std::vector<WorkoutRoute> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::vector<WorkoutRoute>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::vector<WorkoutRoute>>>`.
   */
  using std__shared_ptr_Promise_std__vector_WorkoutRoute___ = std::shared_ptr<Promise<std::vector<WorkoutRoute>>>;
  inline std::shared_ptr<Promise<std::vector<WorkoutRoute>>> create_std__shared_ptr_Promise_std__vector_WorkoutRoute___() noexcept {
    return Promise<std::vector<WorkoutRoute>>::create();
  }
  inline PromiseHolder<std::vector<WorkoutRoute>> wrap_std__shared_ptr_Promise_std__vector_WorkoutRoute___(std::shared_ptr<Promise<std::vector<WorkoutRoute>>> promise) noexcept {
    return PromiseHolder<std::vector<WorkoutRoute>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::vector<WorkoutRoute>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::vector<WorkoutRoute>&)>`.
   */
  using Func_void_std__vector_WorkoutRoute_ = std::function<void(const std::vector<WorkoutRoute>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::vector<WorkoutRoute>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__vector_WorkoutRoute__Wrapper final {
  public:
    explicit Func_void_std__vector_WorkoutRoute__Wrapper(std::function<void(const std::vector<WorkoutRoute>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::vector<WorkoutRoute>& /* result */)>>(std::move(func))) {}
    inline void call(std::vector<WorkoutRoute> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::vector<WorkoutRoute>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__vector_WorkoutRoute_ create_Func_void_std__vector_WorkoutRoute_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__vector_WorkoutRoute__Wrapper wrap_Func_void_std__vector_WorkoutRoute_(Func_void_std__vector_WorkoutRoute_ value) noexcept {
    return Func_void_std__vector_WorkoutRoute__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<QueryStatisticsResponse>
  /**
   * Specialized version of `std::optional<QueryStatisticsResponse>`.
   */
  using std__optional_QueryStatisticsResponse_ = std::optional<QueryStatisticsResponse>;
  inline std::optional<QueryStatisticsResponse> create_std__optional_QueryStatisticsResponse_(const QueryStatisticsResponse& value) noexcept {
    return std::optional<QueryStatisticsResponse>(value);
  }
  inline bool has_value_std__optional_QueryStatisticsResponse_(const std::optional<QueryStatisticsResponse>& optional) noexcept {
    return optional.has_value();
  }
  inline QueryStatisticsResponse get_std__optional_QueryStatisticsResponse_(const std::optional<QueryStatisticsResponse>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::optional<QueryStatisticsResponse>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::optional<QueryStatisticsResponse>>>`.
   */
  using std__shared_ptr_Promise_std__optional_QueryStatisticsResponse___ = std::shared_ptr<Promise<std::optional<QueryStatisticsResponse>>>;
  inline std::shared_ptr<Promise<std::optional<QueryStatisticsResponse>>> create_std__shared_ptr_Promise_std__optional_QueryStatisticsResponse___() noexcept {
    return Promise<std::optional<QueryStatisticsResponse>>::create();
  }
  inline PromiseHolder<std::optional<QueryStatisticsResponse>> wrap_std__shared_ptr_Promise_std__optional_QueryStatisticsResponse___(std::shared_ptr<Promise<std::optional<QueryStatisticsResponse>>> promise) noexcept {
    return PromiseHolder<std::optional<QueryStatisticsResponse>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::optional<QueryStatisticsResponse>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::optional<QueryStatisticsResponse>&)>`.
   */
  using Func_void_std__optional_QueryStatisticsResponse_ = std::function<void(const std::optional<QueryStatisticsResponse>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::optional<QueryStatisticsResponse>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__optional_QueryStatisticsResponse__Wrapper final {
  public:
    explicit Func_void_std__optional_QueryStatisticsResponse__Wrapper(std::function<void(const std::optional<QueryStatisticsResponse>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::optional<QueryStatisticsResponse>& /* result */)>>(std::move(func))) {}
    inline void call(std::optional<QueryStatisticsResponse> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::optional<QueryStatisticsResponse>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__optional_QueryStatisticsResponse_ create_Func_void_std__optional_QueryStatisticsResponse_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__optional_QueryStatisticsResponse__Wrapper wrap_Func_void_std__optional_QueryStatisticsResponse_(Func_void_std__optional_QueryStatisticsResponse_ value) noexcept {
    return Func_void_std__optional_QueryStatisticsResponse__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::unordered_map<std::string, QueryStatisticsResponse>
  /**
   * Specialized version of `std::unordered_map<std::string, QueryStatisticsResponse>`.
   */
  using std__unordered_map_std__string__QueryStatisticsResponse_ = std::unordered_map<std::string, QueryStatisticsResponse>;
  inline std::unordered_map<std::string, QueryStatisticsResponse> create_std__unordered_map_std__string__QueryStatisticsResponse_(size_t size) noexcept {
    std::unordered_map<std::string, QueryStatisticsResponse> map;
    map.reserve(size);
    return map;
  }
  inline std::vector<std::string> get_std__unordered_map_std__string__QueryStatisticsResponse__keys(const std__unordered_map_std__string__QueryStatisticsResponse_& map) noexcept {
    std::vector<std::string> keys;
    keys.reserve(map.size());
    for (const auto& entry : map) {
      keys.push_back(entry.first);
    }
    return keys;
  }
  inline QueryStatisticsResponse get_std__unordered_map_std__string__QueryStatisticsResponse__value(const std__unordered_map_std__string__QueryStatisticsResponse_& map, const std::string& key) noexcept {
    return map.find(key)->second;
  }
  inline void emplace_std__unordered_map_std__string__QueryStatisticsResponse_(std__unordered_map_std__string__QueryStatisticsResponse_& map, const std::string& key, const QueryStatisticsResponse& value) noexcept {
    map.emplace(key, value);
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::unordered_map<std::string, QueryStatisticsResponse>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::unordered_map<std::string, QueryStatisticsResponse>>>`.
   */
  using std__shared_ptr_Promise_std__unordered_map_std__string__QueryStatisticsResponse___ = std::shared_ptr<Promise<std::unordered_map<std::string, QueryStatisticsResponse>>>;
  inline std::shared_ptr<Promise<std::unordered_map<std::string, QueryStatisticsResponse>>> create_std__shared_ptr_Promise_std__unordered_map_std__string__QueryStatisticsResponse___() noexcept {
    return Promise<std::unordered_map<std::string, QueryStatisticsResponse>>::create();
  }
  inline PromiseHolder<std::unordered_map<std::string, QueryStatisticsResponse>> wrap_std__shared_ptr_Promise_std__unordered_map_std__string__QueryStatisticsResponse___(std::shared_ptr<Promise<std::unordered_map<std::string, QueryStatisticsResponse>>> promise) noexcept {
    return PromiseHolder<std::unordered_map<std::string, QueryStatisticsResponse>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::unordered_map<std::string, QueryStatisticsResponse>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::unordered_map<std::string, QueryStatisticsResponse>&)>`.
   */
  using Func_void_std__unordered_map_std__string__QueryStatisticsResponse_ = std::function<void(const std::unordered_map<std::string, QueryStatisticsResponse>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::unordered_map<std::string, QueryStatisticsResponse>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__unordered_map_std__string__QueryStatisticsResponse__Wrapper final {
  public:
    explicit Func_void_std__unordered_map_std__string__QueryStatisticsResponse__Wrapper(std::function<void(const std::unordered_map<std::string, QueryStatisticsResponse>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::unordered_map<std::string, QueryStatisticsResponse>& /* result */)>>(std::move(func))) {}
    inline void call(std::unordered_map<std::string, QueryStatisticsResponse> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::unordered_map<std::string, QueryStatisticsResponse>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__unordered_map_std__string__QueryStatisticsResponse_ create_Func_void_std__unordered_map_std__string__QueryStatisticsResponse_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__unordered_map_std__string__QueryStatisticsResponse__Wrapper wrap_Func_void_std__unordered_map_std__string__QueryStatisticsResponse_(Func_void_std__unordered_map_std__string__QueryStatisticsResponse_ value) noexcept {
    return Func_void_std__unordered_map_std__string__QueryStatisticsResponse__Wrapper(std::move(value));
  }
  
  // pragma MARK: Result<WorkoutSample>
  using Result_WorkoutSample_ = Result<WorkoutSample>;
  inline Result_WorkoutSample_ create_Result_WorkoutSample_(const WorkoutSample& value) noexcept {
    return Result<WorkoutSample>::withValue(value);
  }
  inline Result_WorkoutSample_ create_Result_WorkoutSample_(const std::exception_ptr& error) noexcept {
    return Result<WorkoutSample>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::optional<WorkoutPlan>>>>
  using Result_std__shared_ptr_Promise_std__optional_WorkoutPlan____ = Result<std::shared_ptr<Promise<std::optional<WorkoutPlan>>>>;
  inline Result_std__shared_ptr_Promise_std__optional_WorkoutPlan____ create_Result_std__shared_ptr_Promise_std__optional_WorkoutPlan____(const std::shared_ptr<Promise<std::optional<WorkoutPlan>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::optional<WorkoutPlan>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__optional_WorkoutPlan____ create_Result_std__shared_ptr_Promise_std__optional_WorkoutPlan____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::optional<WorkoutPlan>>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::vector<WorkoutRoute>>>>
  using Result_std__shared_ptr_Promise_std__vector_WorkoutRoute____ = Result<std::shared_ptr<Promise<std::vector<WorkoutRoute>>>>;
  inline Result_std__shared_ptr_Promise_std__vector_WorkoutRoute____ create_Result_std__shared_ptr_Promise_std__vector_WorkoutRoute____(const std::shared_ptr<Promise<std::vector<WorkoutRoute>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<WorkoutRoute>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__vector_WorkoutRoute____ create_Result_std__shared_ptr_Promise_std__vector_WorkoutRoute____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<WorkoutRoute>>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::optional<QueryStatisticsResponse>>>>
  using Result_std__shared_ptr_Promise_std__optional_QueryStatisticsResponse____ = Result<std::shared_ptr<Promise<std::optional<QueryStatisticsResponse>>>>;
  inline Result_std__shared_ptr_Promise_std__optional_QueryStatisticsResponse____ create_Result_std__shared_ptr_Promise_std__optional_QueryStatisticsResponse____(const std::shared_ptr<Promise<std::optional<QueryStatisticsResponse>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::optional<QueryStatisticsResponse>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__optional_QueryStatisticsResponse____ create_Result_std__shared_ptr_Promise_std__optional_QueryStatisticsResponse____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::optional<QueryStatisticsResponse>>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::unordered_map<std::string, QueryStatisticsResponse>>>>
  using Result_std__shared_ptr_Promise_std__unordered_map_std__string__QueryStatisticsResponse____ = Result<std::shared_ptr<Promise<std::unordered_map<std::string, QueryStatisticsResponse>>>>;
  inline Result_std__shared_ptr_Promise_std__unordered_map_std__string__QueryStatisticsResponse____ create_Result_std__shared_ptr_Promise_std__unordered_map_std__string__QueryStatisticsResponse____(const std::shared_ptr<Promise<std::unordered_map<std::string, QueryStatisticsResponse>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::unordered_map<std::string, QueryStatisticsResponse>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__unordered_map_std__string__QueryStatisticsResponse____ create_Result_std__shared_ptr_Promise_std__unordered_map_std__string__QueryStatisticsResponse____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::unordered_map<std::string, QueryStatisticsResponse>>>>::withError(error);
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::shared_ptr<HybridWorkoutProxySpec>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::shared_ptr<HybridWorkoutProxySpec>>>`.
   */
  using std__shared_ptr_Promise_std__shared_ptr_HybridWorkoutProxySpec___ = std::shared_ptr<Promise<std::shared_ptr<HybridWorkoutProxySpec>>>;
  inline std::shared_ptr<Promise<std::shared_ptr<HybridWorkoutProxySpec>>> create_std__shared_ptr_Promise_std__shared_ptr_HybridWorkoutProxySpec___() noexcept {
    return Promise<std::shared_ptr<HybridWorkoutProxySpec>>::create();
  }
  inline PromiseHolder<std::shared_ptr<HybridWorkoutProxySpec>> wrap_std__shared_ptr_Promise_std__shared_ptr_HybridWorkoutProxySpec___(std::shared_ptr<Promise<std::shared_ptr<HybridWorkoutProxySpec>>> promise) noexcept {
    return PromiseHolder<std::shared_ptr<HybridWorkoutProxySpec>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::shared_ptr<HybridWorkoutProxySpec>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::shared_ptr<HybridWorkoutProxySpec>&)>`.
   */
  using Func_void_std__shared_ptr_HybridWorkoutProxySpec_ = std::function<void(const std::shared_ptr<HybridWorkoutProxySpec>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::shared_ptr<HybridWorkoutProxySpec>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__shared_ptr_HybridWorkoutProxySpec__Wrapper final {
  public:
    explicit Func_void_std__shared_ptr_HybridWorkoutProxySpec__Wrapper(std::function<void(const std::shared_ptr<HybridWorkoutProxySpec>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::shared_ptr<HybridWorkoutProxySpec>& /* result */)>>(std::move(func))) {}
    inline void call(std::shared_ptr<HybridWorkoutProxySpec> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::shared_ptr<HybridWorkoutProxySpec>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__shared_ptr_HybridWorkoutProxySpec_ create_Func_void_std__shared_ptr_HybridWorkoutProxySpec_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__shared_ptr_HybridWorkoutProxySpec__Wrapper wrap_Func_void_std__shared_ptr_HybridWorkoutProxySpec_(Func_void_std__shared_ptr_HybridWorkoutProxySpec_ value) noexcept {
    return Func_void_std__shared_ptr_HybridWorkoutProxySpec__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::vector<QuantitySampleForSaving>
  /**
   * Specialized version of `std::vector<QuantitySampleForSaving>`.
   */
  using std__vector_QuantitySampleForSaving_ = std::vector<QuantitySampleForSaving>;
  inline std::vector<QuantitySampleForSaving> create_std__vector_QuantitySampleForSaving_(size_t size) noexcept {
    std::vector<QuantitySampleForSaving> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::vector<std::shared_ptr<HybridWorkoutProxySpec>>
  /**
   * Specialized version of `std::vector<std::shared_ptr<HybridWorkoutProxySpec>>`.
   */
  using std__vector_std__shared_ptr_HybridWorkoutProxySpec__ = std::vector<std::shared_ptr<HybridWorkoutProxySpec>>;
  inline std::vector<std::shared_ptr<HybridWorkoutProxySpec>> create_std__vector_std__shared_ptr_HybridWorkoutProxySpec__(size_t size) noexcept {
    std::vector<std::shared_ptr<HybridWorkoutProxySpec>> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::shared_ptr<Promise<QueryWorkoutSamplesWithAnchorResponse>>
  /**
   * Specialized version of `std::shared_ptr<Promise<QueryWorkoutSamplesWithAnchorResponse>>`.
   */
  using std__shared_ptr_Promise_QueryWorkoutSamplesWithAnchorResponse__ = std::shared_ptr<Promise<QueryWorkoutSamplesWithAnchorResponse>>;
  inline std::shared_ptr<Promise<QueryWorkoutSamplesWithAnchorResponse>> create_std__shared_ptr_Promise_QueryWorkoutSamplesWithAnchorResponse__() noexcept {
    return Promise<QueryWorkoutSamplesWithAnchorResponse>::create();
  }
  inline PromiseHolder<QueryWorkoutSamplesWithAnchorResponse> wrap_std__shared_ptr_Promise_QueryWorkoutSamplesWithAnchorResponse__(std::shared_ptr<Promise<QueryWorkoutSamplesWithAnchorResponse>> promise) noexcept {
    return PromiseHolder<QueryWorkoutSamplesWithAnchorResponse>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const QueryWorkoutSamplesWithAnchorResponse& /* result */)>
  /**
   * Specialized version of `std::function<void(const QueryWorkoutSamplesWithAnchorResponse&)>`.
   */
  using Func_void_QueryWorkoutSamplesWithAnchorResponse = std::function<void(const QueryWorkoutSamplesWithAnchorResponse& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const QueryWorkoutSamplesWithAnchorResponse& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_QueryWorkoutSamplesWithAnchorResponse_Wrapper final {
  public:
    explicit Func_void_QueryWorkoutSamplesWithAnchorResponse_Wrapper(std::function<void(const QueryWorkoutSamplesWithAnchorResponse& /* result */)>&& func): _function(std::make_unique<std::function<void(const QueryWorkoutSamplesWithAnchorResponse& /* result */)>>(std::move(func))) {}
    inline void call(QueryWorkoutSamplesWithAnchorResponse result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const QueryWorkoutSamplesWithAnchorResponse& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_QueryWorkoutSamplesWithAnchorResponse create_Func_void_QueryWorkoutSamplesWithAnchorResponse(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_QueryWorkoutSamplesWithAnchorResponse_Wrapper wrap_Func_void_QueryWorkoutSamplesWithAnchorResponse(Func_void_QueryWorkoutSamplesWithAnchorResponse value) noexcept {
    return Func_void_QueryWorkoutSamplesWithAnchorResponse_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, WorkoutActivityTypePredicate, WorkoutDurationPredicate>
  /**
   * Wrapper struct for `std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, WorkoutActivityTypePredicate, WorkoutDurationPredicate>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate_ {
    std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, WorkoutActivityTypePredicate, WorkoutDurationPredicate> variant;
    std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate_(std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, WorkoutActivityTypePredicate, WorkoutDurationPredicate> variant): variant(variant) { }
    operator std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, WorkoutActivityTypePredicate, WorkoutDurationPredicate>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline PredicateWithUUID get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline PredicateWithUUIDs get_1() const noexcept {
      return std::get<1>(variant);
    }
    inline PredicateWithMetadataKey get_2() const noexcept {
      return std::get<2>(variant);
    }
    inline PredicateWithStartAndEnd get_3() const noexcept {
      return std::get<3>(variant);
    }
    inline PredicateFromWorkout get_4() const noexcept {
      return std::get<4>(variant);
    }
    inline WorkoutActivityTypePredicate get_5() const noexcept {
      return std::get<5>(variant);
    }
    inline WorkoutDurationPredicate get_6() const noexcept {
      return std::get<6>(variant);
    }
  };
  inline std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate_ create_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate_(const PredicateWithUUID& value) noexcept {
    return std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate_(value);
  }
  inline std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate_ create_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate_(const PredicateWithUUIDs& value) noexcept {
    return std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate_(value);
  }
  inline std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate_ create_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate_(const PredicateWithMetadataKey& value) noexcept {
    return std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate_(value);
  }
  inline std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate_ create_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate_(const PredicateWithStartAndEnd& value) noexcept {
    return std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate_(value);
  }
  inline std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate_ create_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate_(const PredicateFromWorkout& value) noexcept {
    return std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate_(value);
  }
  inline std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate_ create_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate_(const WorkoutActivityTypePredicate& value) noexcept {
    return std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate_(value);
  }
  inline std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate_ create_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate_(const WorkoutDurationPredicate& value) noexcept {
    return std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate_(value);
  }
  
  // pragma MARK: std::vector<std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, WorkoutActivityTypePredicate, WorkoutDurationPredicate>>
  /**
   * Specialized version of `std::vector<std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, WorkoutActivityTypePredicate, WorkoutDurationPredicate>>`.
   */
  using std__vector_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__ = std::vector<std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, WorkoutActivityTypePredicate, WorkoutDurationPredicate>>;
  inline std::vector<std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, WorkoutActivityTypePredicate, WorkoutDurationPredicate>> create_std__vector_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__(size_t size) noexcept {
    std::vector<std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, WorkoutActivityTypePredicate, WorkoutDurationPredicate>> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, WorkoutActivityTypePredicate, WorkoutDurationPredicate, PredicateForWorkoutsOr, PredicateForWorkoutsAnd>
  /**
   * Wrapper struct for `std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, WorkoutActivityTypePredicate, WorkoutDurationPredicate, PredicateForWorkoutsOr, PredicateForWorkoutsAnd>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd_ {
    std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, WorkoutActivityTypePredicate, WorkoutDurationPredicate, PredicateForWorkoutsOr, PredicateForWorkoutsAnd> variant;
    std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd_(std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, WorkoutActivityTypePredicate, WorkoutDurationPredicate, PredicateForWorkoutsOr, PredicateForWorkoutsAnd> variant): variant(variant) { }
    operator std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, WorkoutActivityTypePredicate, WorkoutDurationPredicate, PredicateForWorkoutsOr, PredicateForWorkoutsAnd>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline PredicateWithUUID get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline PredicateWithUUIDs get_1() const noexcept {
      return std::get<1>(variant);
    }
    inline PredicateWithMetadataKey get_2() const noexcept {
      return std::get<2>(variant);
    }
    inline PredicateWithStartAndEnd get_3() const noexcept {
      return std::get<3>(variant);
    }
    inline PredicateFromWorkout get_4() const noexcept {
      return std::get<4>(variant);
    }
    inline WorkoutActivityTypePredicate get_5() const noexcept {
      return std::get<5>(variant);
    }
    inline WorkoutDurationPredicate get_6() const noexcept {
      return std::get<6>(variant);
    }
    inline PredicateForWorkoutsOr get_7() const noexcept {
      return std::get<7>(variant);
    }
    inline PredicateForWorkoutsAnd get_8() const noexcept {
      return std::get<8>(variant);
    }
  };
  inline std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd_ create_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd_(const PredicateWithUUID& value) noexcept {
    return std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd_(value);
  }
  inline std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd_ create_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd_(const PredicateWithUUIDs& value) noexcept {
    return std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd_(value);
  }
  inline std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd_ create_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd_(const PredicateWithMetadataKey& value) noexcept {
    return std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd_(value);
  }
  inline std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd_ create_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd_(const PredicateWithStartAndEnd& value) noexcept {
    return std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd_(value);
  }
  inline std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd_ create_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd_(const PredicateFromWorkout& value) noexcept {
    return std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd_(value);
  }
  inline std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd_ create_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd_(const WorkoutActivityTypePredicate& value) noexcept {
    return std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd_(value);
  }
  inline std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd_ create_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd_(const WorkoutDurationPredicate& value) noexcept {
    return std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd_(value);
  }
  inline std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd_ create_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd_(const PredicateForWorkoutsOr& value) noexcept {
    return std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd_(value);
  }
  inline std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd_ create_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd_(const PredicateForWorkoutsAnd& value) noexcept {
    return std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd_(value);
  }
  
  // pragma MARK: std::optional<std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, WorkoutActivityTypePredicate, WorkoutDurationPredicate, PredicateForWorkoutsOr, PredicateForWorkoutsAnd>>
  /**
   * Specialized version of `std::optional<std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, WorkoutActivityTypePredicate, WorkoutDurationPredicate, PredicateForWorkoutsOr, PredicateForWorkoutsAnd>>`.
   */
  using std__optional_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd__ = std::optional<std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, WorkoutActivityTypePredicate, WorkoutDurationPredicate, PredicateForWorkoutsOr, PredicateForWorkoutsAnd>>;
  inline std::optional<std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, WorkoutActivityTypePredicate, WorkoutDurationPredicate, PredicateForWorkoutsOr, PredicateForWorkoutsAnd>> create_std__optional_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd__(const std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, WorkoutActivityTypePredicate, WorkoutDurationPredicate, PredicateForWorkoutsOr, PredicateForWorkoutsAnd>& value) noexcept {
    return std::optional<std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, WorkoutActivityTypePredicate, WorkoutDurationPredicate, PredicateForWorkoutsOr, PredicateForWorkoutsAnd>>(value);
  }
  inline bool has_value_std__optional_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd__(const std::optional<std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, WorkoutActivityTypePredicate, WorkoutDurationPredicate, PredicateForWorkoutsOr, PredicateForWorkoutsAnd>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, WorkoutActivityTypePredicate, WorkoutDurationPredicate, PredicateForWorkoutsOr, PredicateForWorkoutsAnd> get_std__optional_std__variant_PredicateWithUUID__PredicateWithUUIDs__PredicateWithMetadataKey__PredicateWithStartAndEnd__PredicateFromWorkout__WorkoutActivityTypePredicate__WorkoutDurationPredicate__PredicateForWorkoutsOr__PredicateForWorkoutsAnd__(const std::optional<std::variant<PredicateWithUUID, PredicateWithUUIDs, PredicateWithMetadataKey, PredicateWithStartAndEnd, PredicateFromWorkout, WorkoutActivityTypePredicate, WorkoutDurationPredicate, PredicateForWorkoutsOr, PredicateForWorkoutsAnd>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::vector<std::shared_ptr<HybridWorkoutProxySpec>>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::vector<std::shared_ptr<HybridWorkoutProxySpec>>>>`.
   */
  using std__shared_ptr_Promise_std__vector_std__shared_ptr_HybridWorkoutProxySpec____ = std::shared_ptr<Promise<std::vector<std::shared_ptr<HybridWorkoutProxySpec>>>>;
  inline std::shared_ptr<Promise<std::vector<std::shared_ptr<HybridWorkoutProxySpec>>>> create_std__shared_ptr_Promise_std__vector_std__shared_ptr_HybridWorkoutProxySpec____() noexcept {
    return Promise<std::vector<std::shared_ptr<HybridWorkoutProxySpec>>>::create();
  }
  inline PromiseHolder<std::vector<std::shared_ptr<HybridWorkoutProxySpec>>> wrap_std__shared_ptr_Promise_std__vector_std__shared_ptr_HybridWorkoutProxySpec____(std::shared_ptr<Promise<std::vector<std::shared_ptr<HybridWorkoutProxySpec>>>> promise) noexcept {
    return PromiseHolder<std::vector<std::shared_ptr<HybridWorkoutProxySpec>>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::vector<std::shared_ptr<HybridWorkoutProxySpec>>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::vector<std::shared_ptr<HybridWorkoutProxySpec>>&)>`.
   */
  using Func_void_std__vector_std__shared_ptr_HybridWorkoutProxySpec__ = std::function<void(const std::vector<std::shared_ptr<HybridWorkoutProxySpec>>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::vector<std::shared_ptr<HybridWorkoutProxySpec>>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__vector_std__shared_ptr_HybridWorkoutProxySpec___Wrapper final {
  public:
    explicit Func_void_std__vector_std__shared_ptr_HybridWorkoutProxySpec___Wrapper(std::function<void(const std::vector<std::shared_ptr<HybridWorkoutProxySpec>>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::vector<std::shared_ptr<HybridWorkoutProxySpec>>& /* result */)>>(std::move(func))) {}
    inline void call(std::vector<std::shared_ptr<HybridWorkoutProxySpec>> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::vector<std::shared_ptr<HybridWorkoutProxySpec>>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__vector_std__shared_ptr_HybridWorkoutProxySpec__ create_Func_void_std__vector_std__shared_ptr_HybridWorkoutProxySpec__(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__vector_std__shared_ptr_HybridWorkoutProxySpec___Wrapper wrap_Func_void_std__vector_std__shared_ptr_HybridWorkoutProxySpec__(Func_void_std__vector_std__shared_ptr_HybridWorkoutProxySpec__ value) noexcept {
    return Func_void_std__vector_std__shared_ptr_HybridWorkoutProxySpec___Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<WorkoutSessionLocationType>
  /**
   * Specialized version of `std::optional<WorkoutSessionLocationType>`.
   */
  using std__optional_WorkoutSessionLocationType_ = std::optional<WorkoutSessionLocationType>;
  inline std::optional<WorkoutSessionLocationType> create_std__optional_WorkoutSessionLocationType_(const WorkoutSessionLocationType& value) noexcept {
    return std::optional<WorkoutSessionLocationType>(value);
  }
  inline bool has_value_std__optional_WorkoutSessionLocationType_(const std::optional<WorkoutSessionLocationType>& optional) noexcept {
    return optional.has_value();
  }
  inline WorkoutSessionLocationType get_std__optional_WorkoutSessionLocationType_(const std::optional<WorkoutSessionLocationType>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::shared_ptr<HybridWorkoutsModuleSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridWorkoutsModuleSpec>`.
   */
  using std__shared_ptr_HybridWorkoutsModuleSpec_ = std::shared_ptr<HybridWorkoutsModuleSpec>;
  std::shared_ptr<HybridWorkoutsModuleSpec> create_std__shared_ptr_HybridWorkoutsModuleSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridWorkoutsModuleSpec_(std__shared_ptr_HybridWorkoutsModuleSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridWorkoutsModuleSpec>
  using std__weak_ptr_HybridWorkoutsModuleSpec_ = std::weak_ptr<HybridWorkoutsModuleSpec>;
  inline std__weak_ptr_HybridWorkoutsModuleSpec_ weakify_std__shared_ptr_HybridWorkoutsModuleSpec_(const std::shared_ptr<HybridWorkoutsModuleSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::shared_ptr<HybridWorkoutProxySpec>>>>
  using Result_std__shared_ptr_Promise_std__shared_ptr_HybridWorkoutProxySpec____ = Result<std::shared_ptr<Promise<std::shared_ptr<HybridWorkoutProxySpec>>>>;
  inline Result_std__shared_ptr_Promise_std__shared_ptr_HybridWorkoutProxySpec____ create_Result_std__shared_ptr_Promise_std__shared_ptr_HybridWorkoutProxySpec____(const std::shared_ptr<Promise<std::shared_ptr<HybridWorkoutProxySpec>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::shared_ptr<HybridWorkoutProxySpec>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__shared_ptr_HybridWorkoutProxySpec____ create_Result_std__shared_ptr_Promise_std__shared_ptr_HybridWorkoutProxySpec____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::shared_ptr<HybridWorkoutProxySpec>>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<QueryWorkoutSamplesWithAnchorResponse>>>
  using Result_std__shared_ptr_Promise_QueryWorkoutSamplesWithAnchorResponse___ = Result<std::shared_ptr<Promise<QueryWorkoutSamplesWithAnchorResponse>>>;
  inline Result_std__shared_ptr_Promise_QueryWorkoutSamplesWithAnchorResponse___ create_Result_std__shared_ptr_Promise_QueryWorkoutSamplesWithAnchorResponse___(const std::shared_ptr<Promise<QueryWorkoutSamplesWithAnchorResponse>>& value) noexcept {
    return Result<std::shared_ptr<Promise<QueryWorkoutSamplesWithAnchorResponse>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_QueryWorkoutSamplesWithAnchorResponse___ create_Result_std__shared_ptr_Promise_QueryWorkoutSamplesWithAnchorResponse___(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<QueryWorkoutSamplesWithAnchorResponse>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::vector<std::shared_ptr<HybridWorkoutProxySpec>>>>>
  using Result_std__shared_ptr_Promise_std__vector_std__shared_ptr_HybridWorkoutProxySpec_____ = Result<std::shared_ptr<Promise<std::vector<std::shared_ptr<HybridWorkoutProxySpec>>>>>;
  inline Result_std__shared_ptr_Promise_std__vector_std__shared_ptr_HybridWorkoutProxySpec_____ create_Result_std__shared_ptr_Promise_std__vector_std__shared_ptr_HybridWorkoutProxySpec_____(const std::shared_ptr<Promise<std::vector<std::shared_ptr<HybridWorkoutProxySpec>>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<std::shared_ptr<HybridWorkoutProxySpec>>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__vector_std__shared_ptr_HybridWorkoutProxySpec_____ create_Result_std__shared_ptr_Promise_std__vector_std__shared_ptr_HybridWorkoutProxySpec_____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<std::shared_ptr<HybridWorkoutProxySpec>>>>>::withError(error);
  }

} // namespace margelo::nitro::healthkit::bridge::swift
