///
/// ReactNativeHealthkit-Swift-Cxx-Bridge.cpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#include "ReactNativeHealthkit-Swift-Cxx-Bridge.hpp"

// Include C++ implementation defined types
#include "HybridCategoryTypeModuleSpecSwift.hpp"
#include "HybridCharacteristicTypeModuleSpecSwift.hpp"
#include "HybridCoreModuleSpecSwift.hpp"
#include "HybridCorrelationTypeModuleSpecSwift.hpp"
#include "HybridElectrocardiogramModuleSpecSwift.hpp"
#include "HybridHeartbeatSeriesModuleSpecSwift.hpp"
#include "HybridQuantityTypeModuleSpecSwift.hpp"
#include "HybridSourceProxySpecSwift.hpp"
#include "HybridStateOfMindModuleSpecSwift.hpp"
#include "HybridWorkoutProxySpecSwift.hpp"
#include "HybridWorkoutsModuleSpecSwift.hpp"
#include "ReactNativeHealthkit-Swift-Cxx-Umbrella.hpp"

namespace margelo::nitro::healthkit::bridge::swift {

  // pragma MARK: std::function<void(bool /* result */)>
  Func_void_bool create_Func_void_bool(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_bool::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](bool result) mutable -> void {
      swiftClosure.call(result);
    };
  }
  
  // pragma MARK: std::function<void(const std::exception_ptr& /* error */)>
  Func_void_std__exception_ptr create_Func_void_std__exception_ptr(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_std__exception_ptr::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const std::exception_ptr& error) mutable -> void {
      swiftClosure.call(error);
    };
  }
  
  // pragma MARK: std::shared_ptr<HybridSourceProxySpec>
  std::shared_ptr<HybridSourceProxySpec> create_std__shared_ptr_HybridSourceProxySpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    ReactNativeHealthkit::HybridSourceProxySpec_cxx swiftPart = ReactNativeHealthkit::HybridSourceProxySpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::healthkit::HybridSourceProxySpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridSourceProxySpec_(std__shared_ptr_HybridSourceProxySpec_ cppType) {
    std::shared_ptr<margelo::nitro::healthkit::HybridSourceProxySpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::healthkit::HybridSourceProxySpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridSourceProxySpec\" is not implemented in Swift!");
    }
    #endif
    ReactNativeHealthkit::HybridSourceProxySpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::function<void(const std::vector<CategorySample>& /* result */)>
  Func_void_std__vector_CategorySample_ create_Func_void_std__vector_CategorySample_(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_std__vector_CategorySample_::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const std::vector<CategorySample>& result) mutable -> void {
      swiftClosure.call(result);
    };
  }
  
  // pragma MARK: std::shared_ptr<HybridWorkoutProxySpec>
  std::shared_ptr<HybridWorkoutProxySpec> create_std__shared_ptr_HybridWorkoutProxySpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    ReactNativeHealthkit::HybridWorkoutProxySpec_cxx swiftPart = ReactNativeHealthkit::HybridWorkoutProxySpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::healthkit::HybridWorkoutProxySpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridWorkoutProxySpec_(std__shared_ptr_HybridWorkoutProxySpec_ cppType) {
    std::shared_ptr<margelo::nitro::healthkit::HybridWorkoutProxySpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::healthkit::HybridWorkoutProxySpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridWorkoutProxySpec\" is not implemented in Swift!");
    }
    #endif
    ReactNativeHealthkit::HybridWorkoutProxySpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::function<void(const CategorySamplesWithAnchorResponse& /* result */)>
  Func_void_CategorySamplesWithAnchorResponse create_Func_void_CategorySamplesWithAnchorResponse(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_CategorySamplesWithAnchorResponse::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const CategorySamplesWithAnchorResponse& result) mutable -> void {
      swiftClosure.call(result);
    };
  }
  
  // pragma MARK: std::shared_ptr<HybridCategoryTypeModuleSpec>
  std::shared_ptr<HybridCategoryTypeModuleSpec> create_std__shared_ptr_HybridCategoryTypeModuleSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    ReactNativeHealthkit::HybridCategoryTypeModuleSpec_cxx swiftPart = ReactNativeHealthkit::HybridCategoryTypeModuleSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::healthkit::HybridCategoryTypeModuleSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridCategoryTypeModuleSpec_(std__shared_ptr_HybridCategoryTypeModuleSpec_ cppType) {
    std::shared_ptr<margelo::nitro::healthkit::HybridCategoryTypeModuleSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::healthkit::HybridCategoryTypeModuleSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridCategoryTypeModuleSpec\" is not implemented in Swift!");
    }
    #endif
    ReactNativeHealthkit::HybridCategoryTypeModuleSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::function<void(BloodType /* result */)>
  Func_void_BloodType create_Func_void_BloodType(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_BloodType::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](BloodType result) mutable -> void {
      swiftClosure.call(static_cast<int>(result));
    };
  }
  
  // pragma MARK: std::function<void(std::optional<std::chrono::system_clock::time_point> /* result */)>
  Func_void_std__optional_std__chrono__system_clock__time_point_ create_Func_void_std__optional_std__chrono__system_clock__time_point_(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_std__optional_std__chrono__system_clock__time_point_::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](std::optional<std::chrono::system_clock::time_point> result) mutable -> void {
      swiftClosure.call(result);
    };
  }
  
  // pragma MARK: std::function<void(BiologicalSex /* result */)>
  Func_void_BiologicalSex create_Func_void_BiologicalSex(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_BiologicalSex::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](BiologicalSex result) mutable -> void {
      swiftClosure.call(static_cast<int>(result));
    };
  }
  
  // pragma MARK: std::function<void(FitzpatrickSkinType /* result */)>
  Func_void_FitzpatrickSkinType create_Func_void_FitzpatrickSkinType(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_FitzpatrickSkinType::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](FitzpatrickSkinType result) mutable -> void {
      swiftClosure.call(static_cast<int>(result));
    };
  }
  
  // pragma MARK: std::function<void(WheelchairUse /* result */)>
  Func_void_WheelchairUse create_Func_void_WheelchairUse(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_WheelchairUse::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](WheelchairUse result) mutable -> void {
      swiftClosure.call(static_cast<int>(result));
    };
  }
  
  // pragma MARK: std::shared_ptr<HybridCharacteristicTypeModuleSpec>
  std::shared_ptr<HybridCharacteristicTypeModuleSpec> create_std__shared_ptr_HybridCharacteristicTypeModuleSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    ReactNativeHealthkit::HybridCharacteristicTypeModuleSpec_cxx swiftPart = ReactNativeHealthkit::HybridCharacteristicTypeModuleSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::healthkit::HybridCharacteristicTypeModuleSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridCharacteristicTypeModuleSpec_(std__shared_ptr_HybridCharacteristicTypeModuleSpec_ cppType) {
    std::shared_ptr<margelo::nitro::healthkit::HybridCharacteristicTypeModuleSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::healthkit::HybridCharacteristicTypeModuleSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridCharacteristicTypeModuleSpec\" is not implemented in Swift!");
    }
    #endif
    ReactNativeHealthkit::HybridCharacteristicTypeModuleSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::function<void(const std::vector<IdentifierWithUnit>& /* result */)>
  Func_void_std__vector_IdentifierWithUnit_ create_Func_void_std__vector_IdentifierWithUnit_(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_std__vector_IdentifierWithUnit_::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const std::vector<IdentifierWithUnit>& result) mutable -> void {
      swiftClosure.call(result);
    };
  }
  
  // pragma MARK: std::function<void(const std::vector<std::shared_ptr<HybridSourceProxySpec>>& /* result */)>
  Func_void_std__vector_std__shared_ptr_HybridSourceProxySpec__ create_Func_void_std__vector_std__shared_ptr_HybridSourceProxySpec__(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_std__vector_std__shared_ptr_HybridSourceProxySpec__::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const std::vector<std::shared_ptr<HybridSourceProxySpec>>& result) mutable -> void {
      swiftClosure.call(result);
    };
  }
  
  // pragma MARK: std::function<void(const OnChangeCallbackArgs& /* args */)>
  Func_void_OnChangeCallbackArgs create_Func_void_OnChangeCallbackArgs(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_OnChangeCallbackArgs::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const OnChangeCallbackArgs& args) mutable -> void {
      swiftClosure.call(args);
    };
  }
  
  // pragma MARK: std::function<void(double /* result */)>
  Func_void_double create_Func_void_double(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_double::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](double result) mutable -> void {
      swiftClosure.call(result);
    };
  }
  
  // pragma MARK: std::function<void(AuthorizationRequestStatus /* result */)>
  Func_void_AuthorizationRequestStatus create_Func_void_AuthorizationRequestStatus(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_AuthorizationRequestStatus::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](AuthorizationRequestStatus result) mutable -> void {
      swiftClosure.call(static_cast<int>(result));
    };
  }
  
  // pragma MARK: std::function<void(const std::unordered_map<std::string, bool>& /* result */)>
  Func_void_std__unordered_map_std__string__bool_ create_Func_void_std__unordered_map_std__string__bool_(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_std__unordered_map_std__string__bool_::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const std::unordered_map<std::string, bool>& result) mutable -> void {
      swiftClosure.call(result);
    };
  }
  
  // pragma MARK: std::shared_ptr<HybridCoreModuleSpec>
  std::shared_ptr<HybridCoreModuleSpec> create_std__shared_ptr_HybridCoreModuleSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    ReactNativeHealthkit::HybridCoreModuleSpec_cxx swiftPart = ReactNativeHealthkit::HybridCoreModuleSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::healthkit::HybridCoreModuleSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridCoreModuleSpec_(std__shared_ptr_HybridCoreModuleSpec_ cppType) {
    std::shared_ptr<margelo::nitro::healthkit::HybridCoreModuleSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::healthkit::HybridCoreModuleSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridCoreModuleSpec\" is not implemented in Swift!");
    }
    #endif
    ReactNativeHealthkit::HybridCoreModuleSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::function<void(const std::vector<CorrelationSample>& /* result */)>
  Func_void_std__vector_CorrelationSample_ create_Func_void_std__vector_CorrelationSample_(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_std__vector_CorrelationSample_::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const std::vector<CorrelationSample>& result) mutable -> void {
      swiftClosure.call(result);
    };
  }
  
  // pragma MARK: std::shared_ptr<HybridCorrelationTypeModuleSpec>
  std::shared_ptr<HybridCorrelationTypeModuleSpec> create_std__shared_ptr_HybridCorrelationTypeModuleSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    ReactNativeHealthkit::HybridCorrelationTypeModuleSpec_cxx swiftPart = ReactNativeHealthkit::HybridCorrelationTypeModuleSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::healthkit::HybridCorrelationTypeModuleSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridCorrelationTypeModuleSpec_(std__shared_ptr_HybridCorrelationTypeModuleSpec_ cppType) {
    std::shared_ptr<margelo::nitro::healthkit::HybridCorrelationTypeModuleSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::healthkit::HybridCorrelationTypeModuleSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridCorrelationTypeModuleSpec\" is not implemented in Swift!");
    }
    #endif
    ReactNativeHealthkit::HybridCorrelationTypeModuleSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::function<void(const std::vector<ElectrocardiogramSample>& /* result */)>
  Func_void_std__vector_ElectrocardiogramSample_ create_Func_void_std__vector_ElectrocardiogramSample_(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_std__vector_ElectrocardiogramSample_::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const std::vector<ElectrocardiogramSample>& result) mutable -> void {
      swiftClosure.call(result);
    };
  }
  
  // pragma MARK: std::function<void(const ElectrocardiogramSamplesWithAnchorResponse& /* result */)>
  Func_void_ElectrocardiogramSamplesWithAnchorResponse create_Func_void_ElectrocardiogramSamplesWithAnchorResponse(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_ElectrocardiogramSamplesWithAnchorResponse::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const ElectrocardiogramSamplesWithAnchorResponse& result) mutable -> void {
      swiftClosure.call(result);
    };
  }
  
  // pragma MARK: std::shared_ptr<HybridElectrocardiogramModuleSpec>
  std::shared_ptr<HybridElectrocardiogramModuleSpec> create_std__shared_ptr_HybridElectrocardiogramModuleSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    ReactNativeHealthkit::HybridElectrocardiogramModuleSpec_cxx swiftPart = ReactNativeHealthkit::HybridElectrocardiogramModuleSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::healthkit::HybridElectrocardiogramModuleSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridElectrocardiogramModuleSpec_(std__shared_ptr_HybridElectrocardiogramModuleSpec_ cppType) {
    std::shared_ptr<margelo::nitro::healthkit::HybridElectrocardiogramModuleSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::healthkit::HybridElectrocardiogramModuleSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridElectrocardiogramModuleSpec\" is not implemented in Swift!");
    }
    #endif
    ReactNativeHealthkit::HybridElectrocardiogramModuleSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::function<void(const std::vector<HeartbeatSeriesSample>& /* result */)>
  Func_void_std__vector_HeartbeatSeriesSample_ create_Func_void_std__vector_HeartbeatSeriesSample_(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_std__vector_HeartbeatSeriesSample_::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const std::vector<HeartbeatSeriesSample>& result) mutable -> void {
      swiftClosure.call(result);
    };
  }
  
  // pragma MARK: std::function<void(const HeartbeatSeriesSamplesWithAnchorResponse& /* result */)>
  Func_void_HeartbeatSeriesSamplesWithAnchorResponse create_Func_void_HeartbeatSeriesSamplesWithAnchorResponse(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_HeartbeatSeriesSamplesWithAnchorResponse::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const HeartbeatSeriesSamplesWithAnchorResponse& result) mutable -> void {
      swiftClosure.call(result);
    };
  }
  
  // pragma MARK: std::shared_ptr<HybridHeartbeatSeriesModuleSpec>
  std::shared_ptr<HybridHeartbeatSeriesModuleSpec> create_std__shared_ptr_HybridHeartbeatSeriesModuleSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    ReactNativeHealthkit::HybridHeartbeatSeriesModuleSpec_cxx swiftPart = ReactNativeHealthkit::HybridHeartbeatSeriesModuleSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::healthkit::HybridHeartbeatSeriesModuleSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridHeartbeatSeriesModuleSpec_(std__shared_ptr_HybridHeartbeatSeriesModuleSpec_ cppType) {
    std::shared_ptr<margelo::nitro::healthkit::HybridHeartbeatSeriesModuleSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::healthkit::HybridHeartbeatSeriesModuleSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridHeartbeatSeriesModuleSpec\" is not implemented in Swift!");
    }
    #endif
    ReactNativeHealthkit::HybridHeartbeatSeriesModuleSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::function<void(const std::vector<QuantitySample>& /* result */)>
  Func_void_std__vector_QuantitySample_ create_Func_void_std__vector_QuantitySample_(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_std__vector_QuantitySample_::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const std::vector<QuantitySample>& result) mutable -> void {
      swiftClosure.call(result);
    };
  }
  
  // pragma MARK: std::function<void(const QueryStatisticsResponse& /* result */)>
  Func_void_QueryStatisticsResponse create_Func_void_QueryStatisticsResponse(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_QueryStatisticsResponse::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const QueryStatisticsResponse& result) mutable -> void {
      swiftClosure.call(result);
    };
  }
  
  // pragma MARK: std::function<void(const std::vector<QueryStatisticsResponse>& /* result */)>
  Func_void_std__vector_QueryStatisticsResponse_ create_Func_void_std__vector_QueryStatisticsResponse_(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_std__vector_QueryStatisticsResponse_::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const std::vector<QueryStatisticsResponse>& result) mutable -> void {
      swiftClosure.call(result);
    };
  }
  
  // pragma MARK: std::function<void(const QuantitySamplesWithAnchorResponse& /* result */)>
  Func_void_QuantitySamplesWithAnchorResponse create_Func_void_QuantitySamplesWithAnchorResponse(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_QuantitySamplesWithAnchorResponse::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const QuantitySamplesWithAnchorResponse& result) mutable -> void {
      swiftClosure.call(result);
    };
  }
  
  // pragma MARK: std::shared_ptr<HybridQuantityTypeModuleSpec>
  std::shared_ptr<HybridQuantityTypeModuleSpec> create_std__shared_ptr_HybridQuantityTypeModuleSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    ReactNativeHealthkit::HybridQuantityTypeModuleSpec_cxx swiftPart = ReactNativeHealthkit::HybridQuantityTypeModuleSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::healthkit::HybridQuantityTypeModuleSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridQuantityTypeModuleSpec_(std__shared_ptr_HybridQuantityTypeModuleSpec_ cppType) {
    std::shared_ptr<margelo::nitro::healthkit::HybridQuantityTypeModuleSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::healthkit::HybridQuantityTypeModuleSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridQuantityTypeModuleSpec\" is not implemented in Swift!");
    }
    #endif
    ReactNativeHealthkit::HybridQuantityTypeModuleSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::function<void(const std::vector<StateOfMindSample>& /* result */)>
  Func_void_std__vector_StateOfMindSample_ create_Func_void_std__vector_StateOfMindSample_(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_std__vector_StateOfMindSample_::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const std::vector<StateOfMindSample>& result) mutable -> void {
      swiftClosure.call(result);
    };
  }
  
  // pragma MARK: std::shared_ptr<HybridStateOfMindModuleSpec>
  std::shared_ptr<HybridStateOfMindModuleSpec> create_std__shared_ptr_HybridStateOfMindModuleSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    ReactNativeHealthkit::HybridStateOfMindModuleSpec_cxx swiftPart = ReactNativeHealthkit::HybridStateOfMindModuleSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::healthkit::HybridStateOfMindModuleSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridStateOfMindModuleSpec_(std__shared_ptr_HybridStateOfMindModuleSpec_ cppType) {
    std::shared_ptr<margelo::nitro::healthkit::HybridStateOfMindModuleSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::healthkit::HybridStateOfMindModuleSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridStateOfMindModuleSpec\" is not implemented in Swift!");
    }
    #endif
    ReactNativeHealthkit::HybridStateOfMindModuleSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::function<void(const std::optional<WorkoutPlan>& /* result */)>
  Func_void_std__optional_WorkoutPlan_ create_Func_void_std__optional_WorkoutPlan_(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_std__optional_WorkoutPlan_::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const std::optional<WorkoutPlan>& result) mutable -> void {
      swiftClosure.call(result);
    };
  }
  
  // pragma MARK: std::function<void(const std::vector<WorkoutRoute>& /* result */)>
  Func_void_std__vector_WorkoutRoute_ create_Func_void_std__vector_WorkoutRoute_(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_std__vector_WorkoutRoute_::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const std::vector<WorkoutRoute>& result) mutable -> void {
      swiftClosure.call(result);
    };
  }
  
  // pragma MARK: std::function<void(const std::optional<QueryStatisticsResponse>& /* result */)>
  Func_void_std__optional_QueryStatisticsResponse_ create_Func_void_std__optional_QueryStatisticsResponse_(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_std__optional_QueryStatisticsResponse_::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const std::optional<QueryStatisticsResponse>& result) mutable -> void {
      swiftClosure.call(result);
    };
  }
  
  // pragma MARK: std::function<void(const std::unordered_map<std::string, QueryStatisticsResponse>& /* result */)>
  Func_void_std__unordered_map_std__string__QueryStatisticsResponse_ create_Func_void_std__unordered_map_std__string__QueryStatisticsResponse_(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_std__unordered_map_std__string__QueryStatisticsResponse_::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const std::unordered_map<std::string, QueryStatisticsResponse>& result) mutable -> void {
      swiftClosure.call(result);
    };
  }
  
  // pragma MARK: std::function<void(const std::shared_ptr<HybridWorkoutProxySpec>& /* result */)>
  Func_void_std__shared_ptr_HybridWorkoutProxySpec_ create_Func_void_std__shared_ptr_HybridWorkoutProxySpec_(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_std__shared_ptr_HybridWorkoutProxySpec_::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const std::shared_ptr<HybridWorkoutProxySpec>& result) mutable -> void {
      swiftClosure.call(result);
    };
  }
  
  // pragma MARK: std::function<void(const QueryWorkoutSamplesWithAnchorResponse& /* result */)>
  Func_void_QueryWorkoutSamplesWithAnchorResponse create_Func_void_QueryWorkoutSamplesWithAnchorResponse(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_QueryWorkoutSamplesWithAnchorResponse::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const QueryWorkoutSamplesWithAnchorResponse& result) mutable -> void {
      swiftClosure.call(result);
    };
  }
  
  // pragma MARK: std::function<void(const std::vector<std::shared_ptr<HybridWorkoutProxySpec>>& /* result */)>
  Func_void_std__vector_std__shared_ptr_HybridWorkoutProxySpec__ create_Func_void_std__vector_std__shared_ptr_HybridWorkoutProxySpec__(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = ReactNativeHealthkit::Func_void_std__vector_std__shared_ptr_HybridWorkoutProxySpec__::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const std::vector<std::shared_ptr<HybridWorkoutProxySpec>>& result) mutable -> void {
      swiftClosure.call(result);
    };
  }
  
  // pragma MARK: std::shared_ptr<HybridWorkoutsModuleSpec>
  std::shared_ptr<HybridWorkoutsModuleSpec> create_std__shared_ptr_HybridWorkoutsModuleSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    ReactNativeHealthkit::HybridWorkoutsModuleSpec_cxx swiftPart = ReactNativeHealthkit::HybridWorkoutsModuleSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::healthkit::HybridWorkoutsModuleSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridWorkoutsModuleSpec_(std__shared_ptr_HybridWorkoutsModuleSpec_ cppType) {
    std::shared_ptr<margelo::nitro::healthkit::HybridWorkoutsModuleSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::healthkit::HybridWorkoutsModuleSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridWorkoutsModuleSpec\" is not implemented in Swift!");
    }
    #endif
    ReactNativeHealthkit::HybridWorkoutsModuleSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }

} // namespace margelo::nitro::healthkit::bridge::swift
