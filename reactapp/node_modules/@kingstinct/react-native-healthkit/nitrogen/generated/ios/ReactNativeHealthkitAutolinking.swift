///
/// ReactNativeHealthkitAutolinking.swift
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

public final class ReactNativeHealthkitAutolinking {
  public typealias bridge = margelo.nitro.healthkit.bridge.swift

  /**
   * Creates an instance of a Swift class that implements `HybridWorkoutsModuleSpec`,
   * and wraps it in a Swift class that can directly interop with C++ (`HybridWorkoutsModuleSpec_cxx`)
   *
   * This is generated by Nitrogen and will initialize the class specified
   * in the `"autolinking"` property of `nitro.json` (in this case, `WorkoutsModule`).
   */
  public static func createWorkoutsModule() -> bridge.std__shared_ptr_HybridWorkoutsModuleSpec_ {
    let hybridObject = WorkoutsModule()
    return { () -> bridge.std__shared_ptr_HybridWorkoutsModuleSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  /**
   * Creates an instance of a Swift class that implements `HybridCoreModuleSpec`,
   * and wraps it in a Swift class that can directly interop with C++ (`HybridCoreModuleSpec_cxx`)
   *
   * This is generated by Nitrogen and will initialize the class specified
   * in the `"autolinking"` property of `nitro.json` (in this case, `CoreModule`).
   */
  public static func createCoreModule() -> bridge.std__shared_ptr_HybridCoreModuleSpec_ {
    let hybridObject = CoreModule()
    return { () -> bridge.std__shared_ptr_HybridCoreModuleSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  /**
   * Creates an instance of a Swift class that implements `HybridCharacteristicTypeModuleSpec`,
   * and wraps it in a Swift class that can directly interop with C++ (`HybridCharacteristicTypeModuleSpec_cxx`)
   *
   * This is generated by Nitrogen and will initialize the class specified
   * in the `"autolinking"` property of `nitro.json` (in this case, `CharacteristicTypeModule`).
   */
  public static func createCharacteristicTypeModule() -> bridge.std__shared_ptr_HybridCharacteristicTypeModuleSpec_ {
    let hybridObject = CharacteristicTypeModule()
    return { () -> bridge.std__shared_ptr_HybridCharacteristicTypeModuleSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  /**
   * Creates an instance of a Swift class that implements `HybridQuantityTypeModuleSpec`,
   * and wraps it in a Swift class that can directly interop with C++ (`HybridQuantityTypeModuleSpec_cxx`)
   *
   * This is generated by Nitrogen and will initialize the class specified
   * in the `"autolinking"` property of `nitro.json` (in this case, `QuantityTypeModule`).
   */
  public static func createQuantityTypeModule() -> bridge.std__shared_ptr_HybridQuantityTypeModuleSpec_ {
    let hybridObject = QuantityTypeModule()
    return { () -> bridge.std__shared_ptr_HybridQuantityTypeModuleSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  /**
   * Creates an instance of a Swift class that implements `HybridCategoryTypeModuleSpec`,
   * and wraps it in a Swift class that can directly interop with C++ (`HybridCategoryTypeModuleSpec_cxx`)
   *
   * This is generated by Nitrogen and will initialize the class specified
   * in the `"autolinking"` property of `nitro.json` (in this case, `CategoryTypeModule`).
   */
  public static func createCategoryTypeModule() -> bridge.std__shared_ptr_HybridCategoryTypeModuleSpec_ {
    let hybridObject = CategoryTypeModule()
    return { () -> bridge.std__shared_ptr_HybridCategoryTypeModuleSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  /**
   * Creates an instance of a Swift class that implements `HybridCorrelationTypeModuleSpec`,
   * and wraps it in a Swift class that can directly interop with C++ (`HybridCorrelationTypeModuleSpec_cxx`)
   *
   * This is generated by Nitrogen and will initialize the class specified
   * in the `"autolinking"` property of `nitro.json` (in this case, `CorrelationTypeModule`).
   */
  public static func createCorrelationTypeModule() -> bridge.std__shared_ptr_HybridCorrelationTypeModuleSpec_ {
    let hybridObject = CorrelationTypeModule()
    return { () -> bridge.std__shared_ptr_HybridCorrelationTypeModuleSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  /**
   * Creates an instance of a Swift class that implements `HybridElectrocardiogramModuleSpec`,
   * and wraps it in a Swift class that can directly interop with C++ (`HybridElectrocardiogramModuleSpec_cxx`)
   *
   * This is generated by Nitrogen and will initialize the class specified
   * in the `"autolinking"` property of `nitro.json` (in this case, `ElectrocardiogramModule`).
   */
  public static func createElectrocardiogramModule() -> bridge.std__shared_ptr_HybridElectrocardiogramModuleSpec_ {
    let hybridObject = ElectrocardiogramModule()
    return { () -> bridge.std__shared_ptr_HybridElectrocardiogramModuleSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  /**
   * Creates an instance of a Swift class that implements `HybridHeartbeatSeriesModuleSpec`,
   * and wraps it in a Swift class that can directly interop with C++ (`HybridHeartbeatSeriesModuleSpec_cxx`)
   *
   * This is generated by Nitrogen and will initialize the class specified
   * in the `"autolinking"` property of `nitro.json` (in this case, `HeartbeatSeriesModule`).
   */
  public static func createHeartbeatSeriesModule() -> bridge.std__shared_ptr_HybridHeartbeatSeriesModuleSpec_ {
    let hybridObject = HeartbeatSeriesModule()
    return { () -> bridge.std__shared_ptr_HybridHeartbeatSeriesModuleSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  /**
   * Creates an instance of a Swift class that implements `HybridStateOfMindModuleSpec`,
   * and wraps it in a Swift class that can directly interop with C++ (`HybridStateOfMindModuleSpec_cxx`)
   *
   * This is generated by Nitrogen and will initialize the class specified
   * in the `"autolinking"` property of `nitro.json` (in this case, `StateOfMindModule`).
   */
  public static func createStateOfMindModule() -> bridge.std__shared_ptr_HybridStateOfMindModuleSpec_ {
    let hybridObject = StateOfMindModule()
    return { () -> bridge.std__shared_ptr_HybridStateOfMindModuleSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
}
